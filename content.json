{"meta":{"title":"New Life","subtitle":null,"description":"Snape's new life-IT","author":"chen","url":"https://chensnape.github.io"},"pages":[],"posts":[{"title":"索引_oracle","slug":"索引-oracle","date":"2019-09-16T11:06:27.000Z","updated":"2019-09-16T03:26:15.854Z","comments":true,"path":"2019/09/16/索引-oracle/","link":"","permalink":"https://chensnape.github.io/2019/09/16/索引-oracle/","excerpt":"","text":"oracle_1数据库、DDL、DMLoracle_2查看表结构、字段的查询、运算符、列的别名、字符串的拼接 按照范围进行查询、空值的处理、数据的去重、按照列表进行查询、模糊查询oracle_3字段的排序、常用的字符串函数、常用的数值函数、常用的日期函数 常用的聚合(多行)函数、分组查询、分组之后的再次过滤oracle_4子查询、多表查询oracle_5外连接、分页查询、数据的完整性约束oracle_6数据完整性的约束、事务、视图oracle_7序列、索引、表格设计三大样式、JDBCoracle_8SQL注入问题、PreparedStatement预编译的SQL执行环境 JDBC事务、批处理、Properties类与文件、properties配置文件案例oracle_9连接池 、DBCP连接池、数据库优化","categories":[{"name":"索引","slug":"索引","permalink":"https://chensnape.github.io/categories/索引/"}],"tags":[{"name":"索引","slug":"索引","permalink":"https://chensnape.github.io/tags/索引/"}],"keywords":[{"name":"索引","slug":"索引","permalink":"https://chensnape.github.io/categories/索引/"}]},{"title":"9连接池、数据库优化","slug":"9连接池、数据库优化","date":"2019-09-16T11:04:47.000Z","updated":"2019-09-16T03:18:09.212Z","comments":true,"path":"2019/09/16/9连接池、数据库优化/","link":"","permalink":"https://chensnape.github.io/2019/09/16/9连接池、数据库优化/","excerpt":"","text":"连接池 、DBCP连接池、数据库优化2019/9/9 9:07:57 连接池 *概述:连接池用于缓存连接. 连接由连接池创建, 维护. 当我们需要使用连接时, 可以从连接池中获取连接 如果连接池中存在空闲连接, 则取出使用. 如果连接池中不存在空闲连接, 且连接池未满时 , 创建连接并使用, 使用完毕由连接池缓存起来! 如果连接池中不存在空闲连接, 且连接池已满时 , 排队等候空闲连接的出现 ,等候到空闲连接后, 再执行. 需注意: 使用完毕连接池中的连接时, 我们需要通过close关闭它! 连接池中的连接, 使用了动态代理+装饰者设计模式, 我们调用它的close方法, 其实不是在关闭它 , 而是在通知连接池, 此链接我们使用完毕了.DBCP连接池 *使用步骤: 1. 引入相关的jar文件 - dbcp - poll 2. 创建properties文件, 描述连接池的规格 #数据库连接地址 url=jdbc:oracle:thin:@localhost:1521:xe #数据库驱动类的全名 driverClassName=oracle.jdbc.OracleDriver #数据库帐号 username=system #数据库密码 password=123 #初始化连接池时,创建的连接数量 initialSize=5 #连接池的最大连接容量 maxActive=150 #空闲时允许保留的最大连接数量 maxIdle=5 #空闲时允许保留的最小连接数量 minIdle=5 #排队等候的超时时间(毫秒) maxWait=20000 3. 将properites文件, 转换为properties对象 Properties ppt = new Properties(); ppt.load(指向配置文件的输入流); 4. 通过连接池的工厂类(BasicDataSourceFactory) 创建连接池 (一个应用, 拥有一个连接池就够了) DataSource sd = BasicDataSourceFactory.createDataSource(ppt); 5. 通过连接池对象, 获取连接对象 Connection conn = sd.getConnection();数据库优化 *1. 在进行表格查询时 , 列名列表应避免使用*号 , 数据库在执行查询操作时, 会先将*号展开(将*转换为所有的列名) , 再进行查询操作. 2. 在进行表格查询时, 能使用where条件筛选的数据, 应尽量避免使用having子句筛选! 因为where条件执行在having之前 . 尽早的筛除掉大量的数据, 可以显著的提高查询语句的性能. 3. 在进行多表查询时, 查询的表顺序是从右至左的 , 应把表中数据量最少的表 放在查询的最右边. 4. 在进行多表查询时, 应尽可能给所有的表格添加别名 , 能明确的区分有冲突的列. 5. 在使用事务时 , 应尽量多的commit , 尽量早的commit ! 原因是: 事务未提交时, 数据库会耗费大量的内存, 来缓存未提交的SQL结果. 6. 尽可能多的使用函数 来提高SQL执行的效率. 7. SQL语句编写时, 除字符串以外, 应使用大写字母 ,因为SQL语句执行时, 会先将小写字母 ,转换为大写字母!再执行. 8. 应尽可能少的访问数据库. (多次访问数据库的结果 有时是相同的, 如果将结果缓存起来, 可以显著的提高程序的性能) 9. 在索引列上 , 一定要避免使用not来做条件判断. 如果使用了not关键字判断索引列, 会导致此次查询索引失效 . 转而使用全表扫描的方式来查询 10. 在索引列上 , 不能使用算数运算 , 算数运算也会导致本次查询索引失效. 转而使用全表扫描的方式来查询 11. 在查询数据时 , 如果需要使用&gt;或&lt;进行条件判断 , 应替换为&gt;= 或 &lt;= 原因是, 数据库内部在操作&gt;和&lt;时, 是按照&gt;= 和 &lt;= 来查询的 , 然后再撇去=的结果, 得到了&gt;或&lt;的节结果 .准备资源1. 微信公众号 mp.weixin.qq.com 2. 短信发送","categories":[{"name":"oracle","slug":"oracle","permalink":"https://chensnape.github.io/categories/oracle/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"https://chensnape.github.io/tags/oracle/"},{"name":"连接池、数据库优化","slug":"连接池、数据库优化","permalink":"https://chensnape.github.io/tags/连接池、数据库优化/"}],"keywords":[{"name":"oracle","slug":"oracle","permalink":"https://chensnape.github.io/categories/oracle/"}]},{"title":"8SQL注入、JDBC事务","slug":"8SQL注入、JDBC事务","date":"2019-09-16T09:37:59.000Z","updated":"2019-09-16T03:43:13.850Z","comments":true,"path":"2019/09/16/8SQL注入、JDBC事务/","link":"","permalink":"https://chensnape.github.io/2019/09/16/8SQL注入、JDBC事务/","excerpt":"","text":"SQL注入问题、PreparedStatement预编译的SQL执行环境JDBC事务、批处理、Properties类与文件、properties配置文件案例2019/9/6 10:36:49 SQL注入问题 *进行用户登录时, 输入不存在的帐号 输入密码: 1&apos; or &apos;1&apos;=&apos;1 结果是登录成功. select * from user34 where username=&apos;&apos; and password=&apos;&apos; 拼接结果: select * from user34 where username=&apos;hahah&apos; and password=&apos;1&apos; or &apos;1&apos;=&apos;1&apos; 发生问题的原因: 用户输入的内容 与 我们的SQL语句进行了拼接, 拼接完毕后SQL语句的含义改变了. where条件中出现了永真条件 !解决SQL注入问题使用预编译的SQL执行对象, 提前对未拼接参数的字符串 进行编译 ,将其转换为SQL指令. 在向指令中, 传递不具备执行逻辑的参数内容.PreparedStatement 预编译的SQL执行环境 ***内部实现原理: 1. 先将我们的SQL代码, 传递给数据库, 进行预编译! (类似.java 编译为了 class) 2. 再将参数传递给数据库, 此时传递给数据库的内容, 只会被当作文本存在, 不会再作为指令执行. 操作流程 与 Statement基本一致; - 如何得到PreparedStatement对象 PreparedStatement state = 连接对象.prepareStatement(&quot;预编译的SQL语句&quot;); - 预编译SQL语句的格式: 语句中的参数, 使用?代替 , 无论任何类型参数, 都不需要也不能使用引号引住? , 例如: select * from user34 where username=? and password=?; - 如何向预编译的SQL语句中, 填充参数: state.setXXX(int index,XXX value) // XXX表示的是数据类型. 参数1. index sql语句中?的索引值, 从1开始 参数2. value 填充的参数值 - 如何执行SQL语句? - boolean execute() - int executeUpdate() - ResultSet executeQuery()JDBC 事务 *在命令行中操作oracle执行DML时, 需要手动结束事务 (commit 或 rollback) JDBC中, 事务是自动提交的, 每执行一句DML语句, 事务就自动提交一次. 这种特性与数据库无关. 当我们需要使用事务时, 我们可以通过JDBC中的连接对象 , 来取消本次连接 事务的自动提交. 事务: 可以将多条SQL语句, 看作一个整体 , 要么一起成功, 要么一起失败.JDBC中事务的操作格式 *在JDBC中 事务的操作 是通过连接对象完成的. 三个操作事务的方法: 1. setAutoCommit(boolean flag); 设置事务是否自动提交, 仅对当前连接有作用; 默认值为true , false表示关闭自动提交, 开始手动提交. 2. commit(); 提交事务. 3. rollback(); 回滚事务;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960Connection conn = null;PreparedStatement state1 = null;PreparedStatement state2 = null;try &#123; //加载驱动 Class.forName(\"oracle.jdbc.OracleDriver\"); //获取连接对象 conn = DriverManager.getConnection(\"jdbc:oracle:thin:@localhost:1521:xe\", \"system\", \"123\"); //TODO 加入的新逻辑 , 开启事务的手动提交 conn.setAutoCommit(false); //打印流程 System.out.println(\"张衡给洪友发短信: 卡号如下:xxx ,打来50万..\"); System.out.println(\"洪友跟张衡关系好, 打钱中...\"); System.out.println(\"银行程序: 打钱操作执行中...\"); System.out.println(\"银行程序: 正在减少洪友余额500000\"); //预编译 减少洪友余额的SQL语句 state1 = conn.prepareStatement(\"update person set balance=1000000 where name='陈洪友'\"); //执行 state1.executeUpdate(); System.out.println(\"银行程序: 减少完毕\"); System.out.println(\"银行程序: 正在增加张衡的余额500000\"); if(1==1) &#123; throw new RuntimeException(\"哈哈哈, 停电了\"); &#125; //预编译 增加张衡余额的SQL语句 state2 = conn.prepareStatement(\"update person set balance=500002 where name='张衡'\"); //执行 state2.executeUpdate(); //TODO 加入的新逻辑 , 事务提交 conn.commit(); System.out.println(\"银行程序: 增加完毕\"); System.out.println(\"银行程序: 转账完成\");&#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; //TODO 加入的新逻辑 , 事务回退 System.out.println(\"因为停电, 事务回退中...\"); conn.rollback(); &#125; catch (SQLException e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125;&#125;finally &#123; try &#123; if(conn !=null) &#123; conn.close(); &#125; if(state1 !=null) &#123; state1.close(); &#125; if(state2 !=null) &#123; state2.close(); &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125; System.out.println(\"转账完毕, 张衡收到了50万, 开开心心去洗脚了 . \"); 批处理(了解)将多条SQL语句 放到一起批量处理. 批处理能提交大量SQL语句一起执行时的性能. 例如: 当我们需要对数据库执行100此insert 语句时! 不使用批处理, 对数据库的操作指令是100条, 执行了100此. 使用批处理, 是将100条INSERT 语句 转换为一条指令, 执行一次. 批处理使用Statement类操作 实现步骤: 1. 将一条SQL语句, 加入到批处理中 statement,addBatch(String sql); 2. 执行批处理 state.executeBatch();Properties类与文件(掌握)Properties类 是Java中的Map集合的实现类. .properties文件 用于通过文件描述一组键值对! .properties文件 ,可以快速的转换为Properties类的对象. 文件中内容的格式: 文件内容都是字符串 , 键与值之间通过等号连接 , 多个键值对之间换行分割. 例如: url=jdbc:oracle:thin:@localhost:1521:xe username=system password=123 如何将文件 转换为 集合: 步骤: 1. 创建Properties对象 Properties ppt = new Properties(); 2. 创建一个字节输入流 , 指向.properties文件 InputStream is = new FileInputStream(&quot;文件地址&quot;); 3. 将字节输入流, 传递给properties对象, 进行加载. ppt.load(is);###properties 配置文件案例 db.properties: driverClassName=oracle.jdbc.OracleDriver url=jdbc:oracle:thin:@192.168.34.20:1521:orcl username=ruyan password=12345612345678910111213141516171819202122//1. 创建Properties对象Properties config = new Properties();//2. 创建文件输入流, 指向properties文件InputStream is = new FileInputStream(\"C:\\\\code\\\\34\\\\code1\\\\day02_JDBC\\\\src\\\\cn\\\\xdl\\\\demo5\\\\db.properties\");//3. 加载流config.load(is);//4. 取出Properties中的 驱动地址, 连接地址 , 帐号 ,密码String driver = config.getProperty(\"driverClassName\");String url = config.getProperty(\"url\");String username = config.getProperty(\"username\");String password = config.getProperty(\"password\");//5. 加载驱动Class.forName(driver);//6. 通过驱动管理器, 获取连接对象Connection conn = DriverManager.getConnection(url, username, password);//7. 通过连接对象, 预编译SQL语句PreparedStatement state = conn.prepareStatement(\"insert into user342 values(seq_user342_id.nextval,'cqyzs','yibaige6')\");//8. 执行 ,并得到影响的行数int rowNum = state.executeUpdate();System.out.println(rowNum&gt;0?\"插入成功\":\"插入失败\"); ###作业 完成图书管理系统. 功能: 1. 注册 2. 登录 3. 登录完毕展示菜单 - 图书增加 - 请输入 图书名称 简介 作者 定价 (insert) - 图书删除 - 请输入图书名称(delete) - 图书修改 - 请输入图书编号 , 新的图书名称 ,简介 , 作者, 定价 (update) - 图书列表查看 - select","categories":[{"name":"oracle","slug":"oracle","permalink":"https://chensnape.github.io/categories/oracle/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"https://chensnape.github.io/tags/oracle/"},{"name":"SQL注入、JDBC事务","slug":"SQL注入、JDBC事务","permalink":"https://chensnape.github.io/tags/SQL注入、JDBC事务/"}],"keywords":[{"name":"oracle","slug":"oracle","permalink":"https://chensnape.github.io/categories/oracle/"}]},{"title":"7数据库高级特性、JDBC","slug":"7数据库高级特性、JDBC","date":"2019-09-16T09:32:51.000Z","updated":"2019-09-16T03:16:12.459Z","comments":true,"path":"2019/09/16/7数据库高级特性、JDBC/","link":"","permalink":"https://chensnape.github.io/2019/09/16/7数据库高级特性、JDBC/","excerpt":"","text":"序列、索引、表格设计三大样式、JDBC2019/9/4 21:41:15 数据库序列 ***有序的一列数字 , 一般用于对表格id字段的数据插入. 每次使用可以控制其自增, 就像Java中的 i++; 语法格式: - 创建序列: 注意: 序列名称的创建规范: seq_表名_字段名 格式1: create sequence 序列名; *** 格式2: create sequence 序列名 start with 数字--序列的开始数值 increment by 数字--序列每次自增的值 maxvalue 数字--最大值 ; - 使用序列 - 使用不自增: 序列名.currval; - 使用并自增: 序列名.nextval; - 删除序列: - drop sequence 序列名; create sequence seq_user34_id; insert into user34 values(seq_user34_id.nextval,&apos;天海马老师&apos;,&apos;123456&apos;); insert into user34 values(seq_user34_id.nextval,&apos;小泽马老师&apos;,&apos;123456&apos;); insert into user34 values(seq_user34_id.nextval,&apos;加藤马老师&apos;,&apos;123456&apos;); commit;索引 了解索引是数据库 通过 消耗大量的时间 和 控件 来达到加速查询的目的的一种技术. 当我们创建的表格 存在主键 ! 则数据库会自动按照这个字段 为 表格建立索引. 索引技术在查询时, 由数据库自动使用. 语法: 创建: 索引命名规范: index_表名_字段名; create index 索引名称 on 表名(字段名); 删除: drop index 索引名称表格设计三大范式 ***第一范式: 确保表格中每一列的不可分割特性(原子性). 第二范式: 表格中必须存在主键, 表中除了主键以外的字段 都必须完全依赖主键. 第三范式: 确保每一列都和主键列 直接相关 而不是间接相关 (消除间接依赖关系)JDBC(Java DataBase Connectivity) Java数据库连接 注意: 我们学习的是JDBC技术, 不是OJDBC技术 ! JDBC操作任何数据库 步骤, 流程都是一致的 . JDBC是一套标准, 是Java官网与各大数据库厂商共同定制的一套接口, 这套接口由各大数据库厂商进行了自己的实现 ! 我们在连接任意一款数据库产品时, 只需要去对应产品的官网 下载数据库厂商的JDBC实现的类库, 导入到项目中 ,就可以使用.Jar文件的引入1. 在项目中创建文件夹 lib 2. 复制需要引入的.jar文件 3. 粘贴jar文件到lib中. 4. 右键jar文件 5. 选择build-path 6. 选择add to build pathJDBC的使用步骤 *****1. 加载数据库驱动 在进行JavaSE项目开发时, 此步骤可省略. 但是在后续的JavaEE开发中, 必须编写. Class.forName(&quot;oracle.jdbc.OracleDriver&quot;); 2. 通过驱动管理器(DriverManager) , 连接数据库 , 并得到数据库的连接对象 //oracle连接地址: jdbc:oracle:thin:@ip地址:1521:XE Connection conn = DriverManager.getConnection(&quot;数据库地址&quot;,&quot;数据库帐号&quot;,&quot;数据库密码&quot;) 3. 通过连接对象, 创建SQL语句执行对象. Statement state = conn.createStatement(); 4. 通过SQL执行对象, 执行SQL语句 state.execute(&quot;SQL语句&quot;);//方法的返回值为boolean类型, true表示是查询语句 5. 释放执行环境 以及 连接对象 state.close(); conn.close();DriverManager 驱动管理器常用方法: - public static Connection getConnection(String url,String username,String password) 作用: 获取数据库连接对象 参数1: 数据库连接地址 参数2: 数据库的帐号 参数3: 数据库的密码Connection 数据库连接对象使用数据库连接时, 建议: 1. 尽可能晚的创建连接 2. 尽可能早的关闭连接 常用方法: - 创建执行环境 createStatement(); - 关闭连接对象 close();Statement 执行环境 用于执行SQL语句 *****用于执行SQL语句! 常用方法: - 执行SQL语句 public boolean execute(String sql); 参数1: 执行的SQL语句 返回值: true表示执行的是查询语句 - 用于执行DML语句(INSERT | UPDATE | DELETE) public int executeUpdate(String sql); 参数1: 执行的SQL语句 返回值: int类型返回值, 表示当前DML语句执行完毕后, 对表格影响的行数. - 用于执行查询语句(SELECT) public ResultSet executeQuery(String sql); 参数1: 执行的SQL语句 返回值: 结果集对象. ResultSet 结果集对象 . *一个ResultSet对象, 就表示一个查询语句的 查询结果. 常用方法: - 游标移动的方法 - public boolean next() **** 作用: 控制游标向下一行移动 返回值: 下一行存在则移动成功, 移动成功返回true .移动失败表示下一行不存在 ,返回false! - public boolean privious() 了解 作用: 控制游标向上一行移动 返回值: 上一行存在则移动成功, 移动成功返回true .移动失败表示上一行不存在 ,返回false! - public boolean absolute(int rownum); 了解 作用: 控制游标移动到指定行 返回值: 行号存在返回true - public boolean beforeFirst() 了解 作用: 移动到第一行 - public boolean afterLast(); 了解 作用: 移动到最后一行 - 获取游标指向行 数据的方法 - XXX getXXX(String 列名) **** 根据列名, 得到此列的数据 - XXX getXXX(int 列的索引); 根据列的索引, 得到此列的数据. 列的索引按照表格创建时列名顺序排序. 从1开始. 注意: 上述的XXX 指的是数据类型. 例如 获取id int id = 结果集.getInt(&quot;id&quot;); - 释放资源 close();作业:通过控制台 完成用户注册与登录案例 注册: 1. 请用户输入帐号密码. 2. 执行insert 将帐号密码插入到数据库中 登录: 1. 请用户输入帐号密码. 2. 执行select 查询帐号与密码是否存在 select id from user34 where username=xxx and password=xx;","categories":[{"name":"oracle","slug":"oracle","permalink":"https://chensnape.github.io/categories/oracle/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"https://chensnape.github.io/tags/oracle/"},{"name":"数据库高级特性、JDBC","slug":"数据库高级特性、JDBC","permalink":"https://chensnape.github.io/tags/数据库高级特性、JDBC/"}],"keywords":[{"name":"oracle","slug":"oracle","permalink":"https://chensnape.github.io/categories/oracle/"}]},{"title":"6PLSQL","slug":"6PLSQL","date":"2019-09-16T09:27:13.000Z","updated":"2019-09-16T03:44:42.497Z","comments":true,"path":"2019/09/16/6PLSQL/","link":"","permalink":"https://chensnape.github.io/2019/09/16/6PLSQL/","excerpt":"","text":"���������Ե�Լ����������ͼ2019/9/3 19:45:36 ���������Ե�Լ��(����֮��)�ع�ѧ����Լ������Լ��(primary key) - Ҫ����ֶε���ֵΨһ�Ҳ���Ϊ�գ� ΨһԼ��(unique) - Ҫ����ֶε���ֵΨһ������Ϊ�գ� �ǿ�Լ��(not null) - Ҫ����ֶε���ֵ����Ϊ�գ� ���Լ��(check) - Ҫ����ֶε���ֵ��������ָ���ĸ�ʽ��Χ�ȣ����Լ����������ĳһ�ֶε���ֵȡ��������һ�ű�������ʱ�����ֶξ���Ҫ�������Լ���� Ҳ�����������ⲿ����������ǰ�������ӱ����������ı��������� id student�� ���� - ���� studentid result�� - �ӱ�123456789101112131415161718192021222324252627-- ɾ���û���drop table user1;-- ����һ���û������ֶ��У��û���š��û����ƣ�Ҫ���û������Ϊ����������create table user1( id number constraint pk_id primary key, name varchar2(30) constraint nn_name not null);-- ���û����в�������insert into user1 values(1, '����');insert into user1 values(2, '��־ΰ');-- ɾ��������drop table order1;-- ����һ�����������ֶ��У�������š��������ơ��û����create table order1( oid number constraint pk_oid primary key, oname varchar2(50) constraint nn_oname not null, -- ��ʾ���ֶ�userid������user1��������Ϊid���ֶ� userid number constraint fk_userid references user1(id)); -- �򶩵����в�������insert into order1 values(101, 'һ֧��', 1);insert into order1 values(102, 'һ����', 2);-- �﷨��ȷ���߼�������Ϊ�û�����û��3���û���û�е�¼���û��޷��ύ����-- ���������Լ��������Ĵ������뱨��insert into order1 values(103, 'һ����', 3); 123456789101112131415161718192021222324252627 -- ��ʶһ�±���Լ�� create table order1( -- ��ʾ���ֶ�userid������user1��������Ϊid���ֶ� userid number, constraint fk_userid foreign key(userid) references user1(id) ); -- �����ű��Ѿ���������Ҳ������ݺ� ɾ������ʱ�Ĵ�������-- ɾ���û����б��Ϊ1���û�-- Error:���ڸ��û���order1�����м�¼��Ҳ���Ǳ�order1��ʹ��delete from user1 where id = 1;-- ��һ��ɾ����ʽ�����ӱ�order1���������˻���ŵļ�¼ɾ����Ȼ����ɾ������user1�еļ�¼delete from order1 where userid = 1;delete from user1 where id = 1;-- �ڶ���ɾ����ʽ�����ӱ�order1���������˻���ŵļ�¼�ÿգ�Ȼ����ɾ������user1�еļ�¼update order1 set userid = null where userid = 1;delete from user1 where id = 1;-- �����ַ�ʽ��ֱ�ӽ��ӱ�order1����ɾ������ɾ������user1drop table order1;drop table user1;-- �����ַ�ʽ��ɾ������ʱȡ����֮��Ĺ�����ϵdrop table user1 cascade constraint; 1234567891011121314151617181920212223242526272829303132333435363738394041424344-- �ڴ�����ʱ������ɾ����׼��-- ɾ���û��� drop table user1; -- ����һ���û������ֶ��У��û���š��û����ƣ�Ҫ���û������Ϊ���������� create table user1( id number constraint pk_id primary key, name varchar2(30) constraint nn_name not null ); -- ���û����в������� insert into user1 values(1, '����'); insert into user1 values(2, '��־ΰ'); -- ɾ�������� drop table order1; -- ����һ�����������ֶ��У�������š��������ơ��û���� create table order1( oid number constraint pk_oid primary key, oname varchar2(50) constraint nn_oname not null, -- ��ʾ���ֶ�userid������user1��������Ϊid���ֶ� userid number constraint fk_userid references user1(id) on delete set null ); -- �򶩵����в������� insert into order1 values(101, 'һ֧��', 1); insert into order1 values(102, 'һ����', 2); -- ɾ���û����б��Ϊ1���û� -- OK:��ʱ�û����б��Ϊ1���û���¼�ᱻɾ�������������ж�Ӧ�ļ�¼�Զ���Ϊ�� delete from user1 where id = 1; -- ɾ�������� drop table order1; -- ����һ�����������ֶ��У�������š��������ơ��û���� create table order1( oid number constraint pk_oid primary key, oname varchar2(50) constraint nn_oname not null, -- ��ʾ���ֶ�userid������user1��������Ϊid���ֶ� userid number constraint fk_userid references user1(id) on delete cascade ); -- �򶩵����в������� insert into order1 values(101, 'һ֧��', 1); insert into order1 values(102, 'һ����', 2); -- ɾ���û����б��Ϊ1���û� -- OK:��ʱ�û����б��Ϊ1���û���¼�ᱻɾ�������������ж�Ӧ�ļ�¼�Զ�ɾ�� delete from user1 where id = 1; ����(����֮�ء��ѵ㡢��������)���������-- ʹ��ͼ�λ��������꼶���в�������,�˲������ʵ����ֻ�ǰ����ݷŵ��ڴ��� insert into grade values(7, &apos;����&apos;); -- û�н����ύʱ�������й����޷����в����������Ϊͼ�λ����ߵ�����û������ -- ���������ݿⱻ��ס��ֱ��ͼ�λ����ߵ�����������ܽ��� -- ���ͼ�λ�����ִ�е����� ���� һ������ -- ʹ��commitʵ�����ݵ��ύ���ŻὫ�������ڴ���뵽���ݿ�ı��ռ��� commit; -- ��ѯ�꼶���е�������Ϣ select * from grade; ע�⣺ ���Ժ�Ŀ�����ֻҪʹ�õ�dml���һ��Ҫ�ǵ�commit�Ż��ύ�����ݿ��������ʹ��123456789101112131415161718192021222324252627282930313233-- ɾ���˻���drop table bank;-- ���������˻������ֶΣ��˺ţ��˻����create table bank( id number primary key, money number check(money &gt;= 0) );-- ���������˻�����Ϣinsert into bank values(1, 100);insert into bank values(2, 100);-- ģ��ת�˲�����ʵ��1���˻���2���˻�ת��50Ԫ-- ��1���˻�����ʱ���µ�һ������ʧ��update bank set money = money-50 where id = 1;-- ��Ȼ��һ��ʧ���ˣ����ڶ���ȱִ�гɹ�����ʱ����ʵ�����-- ����ϣ�����ǣ�ֻҪ��һ��ʧ����������ʧ�ܣ�ֻ���������ɹ�����ųɹ�update bank set money = money+50 where id = 2;-- ʹ�������������һ��ɹ���һ��ʧ��begin -- ģ��ת�˲�����ʵ��1���˻���2���˻�ת��50Ԫ -- ��1���˻�����ʱ���µ�һ������ʧ�� update bank set money = money-50 where id = 1; -- ��Ȼ��һ��ʧ���ˣ����ڶ���ȱִ�гɹ�����ʱ����ʵ����� -- ����ϣ�����ǣ�ֻҪ��һ��ʧ����������ʧ�ܣ�ֻ���������ɹ�����ųɹ� update bank set money = money+50 where id = 2; commit; -- �ύ��һ��ɹ� exception -- �൱��Java��catch when others then rollback; -- �ع���һ��ʧ��end; 1234567891011121314151617181920212223242526272829303132333435363738394041424344-- ʹ��������ģ����У�����İ���begin -- 1.����HistoryResult��ʷ�ɼ������ֶ���result���е��ֶ�һ�� CREATE TABLE HistoryResult( Id number(4) primary key, StudentNo varchar2(50) NOT NULL, SubjectId number(2) NOT NULL, StudentResult number(4) NULL, ExamDate date NOT NULL ); -- 2.��ѯResult�������С��������׶�ѧ���Ŀ��Գɼ������浽��HistoryResult�� insert into HistoryResult select * from result where subjectid in ( select subjectid from subject where gradeid = ( select gradeid from grade where gradename = '����' )); -- 3.ɾ��Result�������С��������׶�ѧ���Ŀ��Գɼ� delete from result where subjectid in ( select subjectid from subject where gradeid = ( select gradeid from grade where gradename = '����' )); -- 4.����HistoryStudent��ʷѧ�������ֶ���student���е��ֶ�һ�� CREATE TABLE HistoryStudent( StudentNo varchar2(50) NOT NULL primary key, LoginPwd varchar2(20) NOT NULL, StudentName varchar2(50) NOT NULL, Sex char(3) NOT NULL, GradeId number(2,0) NOT NULL, Phone varchar2(255) NOT NULL, Address varchar2(255) NULL, BornDate date NULL, Email varchar2(50) NULL ); -- 5.��ѯStudent�������С��������׶ε�ѧ����¼�����浽��HistoryStudent�� insert into HistoryStudent select * from student where gradeid = ( select gradeid from grade where gradename = '����'); -- 6.ɾ��Student�������С��������׶�ѧ����¼ delete from student where gradeid = ( select gradeid from grade where gradename = '����'); commit; -- һ��ɹ� exception when others then rollback; -- һ��ʧ��end; ��ͼ(����֮��)��ͼ����������ͬһ�ű��е�������˵����ͬ����Ⱥ���ܹ�ע��ͬ�����ݣ�������ͬ�����ݷ��ڲ�ͬ�ı��л���ɱ��ռ���˷ѣ���ʱ����ʹ����ͼ����������� ��ͼ�����Ͼ�������չʾ�������в����ֶλ��߶�������ۺ��ֶε����������ͼ�Ĵ�����ɾ��(1)������ͼ���﷨��ʽ create view vw_��ͼ�� as select��ѯ���;123456789-- ����һ����ͬѧ���ĵ���ͼ: ����Ůͬѧ�����ֺ͵绰create view vw_girlsasselect studentname ����, phone �绰���� from studentwhere sex = 'Ů';-- ��ѯ��ͼ�е�����select * from vw_girls; (2)ɾ����ͼ���﷨��ʽ drop view vw_��ͼ��; �磺 drop view vw_girls;�������⣺12345678910111213141516171819202122232425262728293031323334-- ����һ����ʦ��ע��ѧ����ͼ-- ��ʾ���ֶΣ�������ѧ�ţ���Ŀ���ƣ����Գɼ�������ʱ��-- �漰������studentѧ���� subject�γ̱� result�ɼ���create view vw_teacherasselect studentname ����, student.studentno ѧ��, subjectname �γ�����, studentresult ���Գɼ�, examdate ��������from student, subject, resultwhere student.studentno = result.studentno and result.subjectid = subject.subjectid;-- ��ʾ���ֶΣ�������ѧ�ţ��绰���꼶��ţ��ɼ�select studentname ����, student.studentno ѧ��, phone �绰, gradeid �꼶���, studentresult �ɼ�from student, result where student.studentno = result.studentno;-- �����ܳɼ�select studentname ����, student.studentno ѧ��, phone �绰, gradeid �꼶���, sum(studentresult) �ɼ�from student, resultwhere student.studentno = result.studentnogroup by studentname, student.studentno, phone, gradeid;-- ����һ�������ι�ע�ֶε���ͼ-- ��ʾ���ֶΣ�������ѧ�ţ��绰���꼶��ţ��꼶�ܷ�create view vw_banzhurenasselect studentname ����, student.studentno ѧ��, phone �绰, gradeid �꼶���, sum(studentresult) �ɼ�from student, resultwhere student.studentno = result.studentnogroup by studentname, student.studentno, phone, gradeid; ��ҵ��1.��ϰ���ܽ�Oracle���ݿ���������ݡ�","categories":[{"name":"oracle","slug":"oracle","permalink":"https://chensnape.github.io/categories/oracle/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"https://chensnape.github.io/tags/oracle/"},{"name":"PLSQL","slug":"PLSQL","permalink":"https://chensnape.github.io/tags/PLSQL/"}],"keywords":[{"name":"oracle","slug":"oracle","permalink":"https://chensnape.github.io/categories/oracle/"}]},{"title":"5数据库特性","slug":"5数据库特性","date":"2019-09-16T09:23:36.000Z","updated":"2019-09-16T03:14:25.507Z","comments":true,"path":"2019/09/16/5数据库特性/","link":"","permalink":"https://chensnape.github.io/2019/09/16/5数据库特性/","excerpt":"","text":"外连接、分页查询、数据的完整性约束2019/9/3 19:31:42 select查询语句(重中之重)复习内连接所谓内连接就是指将满足关联条件，并且两张表都有的数据内容显示出来。 语法格式(旧版)： select [表名1.]字段名1 别名1, [表名2.]字段名2, ... from 表名1 [别名1], 表名2 [别名2] where 两张表的关联条件; 语法格式(新版): select [表名1.]字段名1 别名1, [表名2.]字段名2, ... from 表名1 [别名1] inner join 表名2 [别名2] on 两张表的关联条件;左外连接所谓左外连接就是指将满足关联条件且两张表都有的数据显示之后，将左表中存在但右表中没有匹配的数据也会显示出来 只是将右表中没有数据使用null填充。 也就是说以左表为主，将左表的所有数据显示出来。 语法格式(旧版): select [表名1.]字段名1 别名1, [表名2.]字段名2, ... from 表名1 [别名1], 表名2 [别名2] where [表名1.]字段名 关联 [表名2.]字段名(+); 语法格式(新版)： select [表名1.]字段名1 别名1, [表名2.]字段名2, ... from 表名1 [别名1] left outer join 表名2 [别名2] on 两张表的关联条件;123456789101112131415161718192021222324252627-- 查询学生的名称、课程的编号以及对应的考试成绩 使用内连接-- 该需求涉及到：student学生表 和 result成绩表 通过studentno学号关联select studentname, subjectid, studentresult from student, resultwhere student.studentno = result.studentno; -- 查询学生的名称、课程的编号以及对应的考试成绩 使用左外连接-- 该需求涉及到：student学生表 和 result成绩表 通过studentno学号关联select studentname, subjectid, studentresult from student, resultwhere student.studentno = result.studentno(+); -- 查询学生的名称、课程的编号以及对应的考试成绩 使用内连接-- 该需求涉及到：student学生表 和 result成绩表 通过studentno学号关联-- 新版格式select studentname, subjectid, studentresult from student inner join resulton student.studentno = result.studentno; -- 查询学生的名称、课程的编号以及对应的考试成绩 使用左外连接-- 该需求涉及到：student学生表 和 result成绩表 通过studentno学号关联-- 新版格式select studentname, subjectid, studentresult from student left outer join resulton student.studentno = result.studentno; select studentname, subjectid, studentresult from student left join resulton student.studentno = result.studentno; 右外连接所谓右外连接就是指将满足关联条件且两张表都有的数据显示之后，将右表中存在但左表中没有匹配的数据也会显示出来 只是将左表中没有数据使用null填充。 也就是说以右表为主，将右表的所有数据显示出来。 语法格式(旧版): select [表名1.]字段名1 别名1, [表名2.]字段名2, ... from 表名1 [别名1], 表名2 [别名2] where [表名1.]字段名(+) 关联 [表名2.]字段名; 语法格式(新版)： select [表名1.]字段名1 别名1, [表名2.]字段名2, ... from 表名1 [别名1] right outer join 表名2 [别名2] on 两张表的关联条件;1234567891011121314151617-- 若成绩表中没有多余的数据，则使用insert into插入一个数据测试-- 查询学生的名称、课程的编号以及对应的考试成绩 使用右外连接-- 该需求涉及到：student学生表 和 result成绩表 通过studentno学号关联select studentname, subjectid, studentresult from student, resultwhere student.studentno(+) = result.studentno; -- 查询学生的名称、课程的编号以及对应的考试成绩 使用左外连接-- 该需求涉及到：student学生表 和 result成绩表 通过studentno学号关联-- 新版格式select studentname, subjectid, studentresult from student right outer join resulton student.studentno = result.studentno; -- 使用左外来完成右外的功能select studentname, subjectid, studentresult from result left outer join student on student.studentno = result.studentno; 全外连接所谓全外连接就是指将满足关联条件且两张表都有的数据显示之后，将左右表中存在但没有匹配的数据也会显示出来 只是将左右表中没有数据使用null填充。 也就是说以左右表为主，将左右表的所有数据显示出来。 语法格式(旧版不支持！) 语法格式(新版)： select [表名1.]字段名1 别名1, [表名2.]字段名2, ... from 表名1 [别名1] full outer join 表名2 [别名2] on 两张表的关联条件;1234567891011121314-- 若成绩表中没有多余的数据，则使用insert into插入一个数据测试-- 查询学生的名称、课程的编号以及对应的考试成绩 使用右外连接-- 该需求涉及到：student学生表 和 result成绩表 通过studentno学号关联-- Error: 老版不支持全外连接select studentname, subjectid, studentresult from student, resultwhere student.studentno(+) = result.studentno(+); -- 查询学生的名称、课程的编号以及对应的考试成绩 使用左外连接-- 该需求涉及到：student学生表 和 result成绩表 通过studentno学号关联-- 新版格式 内：88 左外：118 右外：89 全外：119 select studentname, subjectid, studentresult from student full outer join resulton student.studentno = result.studentno; 练习:1234567891011121314151617181920212223242526-- 查询所有科目的考试信息 -- 该需求涉及到：subject科目表 和 result成绩表 采用subjectid进行关联-- 所有的科目都要显示，考试信息有就显示，没有使用null填充 左外连接select subject.subjectid 课程编号, subjectname 课程名称, studentresult 考试成绩，to_char(examdate, 'yyyy-mm-dd') 考试日期 from subject left outer join resulton subject.subjectid = result.subjectid; -- 查询所有考试的科目信息 右外连接-- 由结果可知：右表中没有左表不匹配的额外数据select subject.subjectid 课程编号, subjectname 课程名称, studentresult 考试成绩，to_char(examdate, 'yyyy-mm-dd') 考试日期 from subject right outer join resulton subject.subjectid = result.subjectid; -- 查询从未考试的科目信息select subjectid 课程编号, subjectname 课程名称 from subjectwhere subjectid not in( select distinct subjectid from result); -- 查询所有年级对应的学生信息-- 该需求涉及到：grade年级表 student学生表 使用 gradeid年级编号关联-- 要求年级表中的数据全部显示，和学生表去匹配，因此使用左外连接select grade.gradeid 年级编号, gradename 年级名称, studentname 学生姓名from grade left outer join studenton grade.gradeid = student.gradeid; 分页查询由于查询到的数据内容比较多无法在一个页面中全部显示，因此可以将查询到的数据内容分成很多页分别显示即可 这样的机制就叫分页查询。123456789101112131415-- 查询员工表中的所有员工的编号、员工的名字以及员工的薪水select id, first_name, salary from s_emp; -- 采用分页查询技术，将每10个员工的信息组成一页 -- delete from s_emp where id = 2;-- 使用员工编号来分页的最大缺陷：当有员工离职时，会造成查询到的页面数据不够-- 查询第一页，员工编号从1 ~ 10select id, first_name, salary from s_empwhere id between 1 and 10;-- 查询第二页，员工编号从11 ~ 20select id, first_name, salary from s_empwhere id between 11 and 20;-- 查询第三页，员工编号从21 ~ 30select id, first_name, salary from s_empwhere id between 21 and 30; 分页查询的优化：123456789101112131415161718192021222324-- 查询员工表中所有员工的编号、员工的名字以及员工的薪水 显示伪列select rownum 分页编号, id 员工编号, first_name 员工的名字, salary 员工薪水from s_emp; -- 当使用伪列时，若表中有员工离职，则不影响伪列的编号delete from s_emp where id = 2;-- 借助伪列实现真正的分页查询, 采用三层子查询-- 第一步：查询到员工表中的所有信息select * from s_emp;-- 第二步：将查询到的虚拟表看做是一张新表，使用伪列给这个新表进行编号select rownum, e.* from (select * from s_emp) e; -- 第三步：根据伪列的数值对已经查询到的所有内容进行分页显示select id 员工编号, first_name 员工的名字, salary 员工薪水from (select rownum r, e.* from (select * from s_emp order by id) e)where r between 1 and 10; select id 员工编号, first_name 员工的名字, salary 员工薪水from (select rownum r, e.* from (select * from s_emp order by id) e)where r between 11 and 20;select id 员工编号, first_name 员工的名字, salary 员工薪水from (select rownum r, e.* from (select * from s_emp order by id) e)where r between 21 and 30; 数据的完整性约束(重中之重)基本概念为了避免以后向表中插入一些错误或不符合规范的数据，就需要程序员在设计表时建立表中数据的完整性约束。 完整性主要包括四大类：域完整性、实体完整性、自定义完整性、引用完整性。主键约束当创建表时指定主键约束可以确保该字段(列)中的数据唯一并且不能为空。12345678910111213141516-- 创建一个worker工人表create table worker( -- 相当于给字段id加入主键约束 -- 约束关键字 约束名称 约束类型 id number constraint pk_id primary key -- 描述工人表的工号字段);-- 向表中插入数据insert into worker values(1);insert into worker values(2);-- 工号重复但没有报错，加入主键约束后下面的代码会报错insert into worker values(1);-- 不能为空insert into worker values(null);-- 删除工人表drop table worker; 唯一约束当创建表时指定唯一约束则可以确保该字段(列)中的数据唯一但可以为空。 注意：只能有一个空值1234567891011121314151617181920-- 创建一个worker工人表create table worker( -- 相当于给字段id加入主键约束 -- 约束关键字 约束名称 约束类型 -- 描述工人表的工号字段 id number constraint pk_id primary key, -- 相当于给字段name加入唯一约束 name varchar2(30) constraint uq_name unique );-- 向表中插入数据insert into worker values(1, '张飞');insert into worker values(2, '关羽');-- 工号重复但没有报错，加入唯一约束后下面的代码会报错insert into worker values(3, '张飞');-- 不能为空insert into worker values(4, null);-- 虽然没有报错，但不允许有过多的null值insert into worker values(5, null);-- 删除工人表drop table worker; 非空约束当创建表时指定非空约束则可以确保该字段(列)中的数据不能为空。12345678910111213141516171819-- 创建一个worker工人表create table worker( -- 相当于给字段id加入主键约束 -- 约束关键字 约束名称 约束类型 -- 描述工人表的工号字段 id number constraint pk_id primary key, -- 相当于给字段name加入唯一约束 name varchar2(30) constraint uq_name unique, -- 相当于给字段sex加入非空约束 sex char(3) constraint nn_sex not null );-- 向表中插入数据insert into worker values(1, '张飞', '男');insert into worker values(2, '关羽', '男');-- 此时应该报错，违反非空约束insert into worker values(3, '刘备', null);-- 删除工人表drop table worker; 检查约束当创建表时指定检查约束则可以确保该字段(列)中的数据不能超过取值范围和格式限制123456789101112131415161718192021-- 创建一个worker工人表create table worker( -- 相当于给字段id加入主键约束 -- 约束关键字 约束名称 约束类型 -- 描述工人表的工号字段 id number constraint pk_id primary key, -- 相当于给字段name加入唯一约束 name varchar2(30) constraint uq_name unique, -- 相当于给字段sex加入非空约束 sex char(3) constraint nn_sex not null, -- 相当于给字段salary加入检查约束 约束说明 salary number(11, 2) constraint ck_salary check(salary &gt;= 2200) );-- 向表中插入数据insert into worker values(1, '张飞', '男', 3000);insert into worker values(2, '关羽', '男', 4000);-- 此时应该报错，违反检查约束insert into worker values(3, '刘备', '男', 2000);-- 删除工人表drop table worker; 表级约束当创建表时写完所有的字段列表后再写约束规则的形式，就叫做表级约束。12345678910111213141516171819202122232425-- 创建一个worker工人表create table worker( -- 相当于给字段id加入主键约束 -- 约束关键字 约束名称 约束类型 -- 描述工人表的工号字段 id number, -- 相当于给字段name加入唯一约束 name varchar2(30), -- 相当于给字段sex加入非空约束 sex char(3) , -- 相当于给字段salary加入检查约束 约束说明 salary number(11, 2) , constraint pk_id primary key(id), constraint uq_name unique(name), -- constraint nn_sex not null(sex), 非空没有表级约束 constraint ck_salary check(salary &gt;= 2200));-- 向表中插入数据insert into worker values(1, '张飞', '男', 3000);insert into worker values(2, '关羽', '男', 4000);-- 此时应该报错，违反检查约束insert into worker values(3, '刘备', '男', 2000);-- 删除工人表drop table worker; 创建表后约束的控制当一个表已经创建完毕后，若希望添加或者删除约束时的处理方式如下：12345678910111213141516171819202122232425-- 删除工人表drop table worker;-- 创建一个worker工人表create table worker( id number, name varchar2(30), sex char(3), salary number(11, 2) ); -- 通过修改表结构的方式来添加约束，注意表格中不要有数据alter table workeradd constraint pk_id primary key(id);-- 向表中插入数据insert into worker values(1, '张飞', '男', 3000);insert into worker values(2, '关羽', '男', 4000);-- 此时应该报错，违反主键约束insert into worker values(1, '刘备', '男', 5000); -- 通过修改表结构的方式来删除约束alter table workerdrop constraint pk_id;-- 此时应该可以insert into worker values(1, '刘备', '男', 5000); 作业：-- 向s_emp表中增加一个任意的员工信息 -- 向s_dept表中添加一个任意的部门信息 -- 分别使用左外、右外、全外连接实现s_emp表和s_dept表的连接和查询 -- 实现学生表中的分页显示，每页显示10个学生信息","categories":[{"name":"oracle","slug":"oracle","permalink":"https://chensnape.github.io/categories/oracle/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"https://chensnape.github.io/tags/oracle/"},{"name":"数据库特性","slug":"数据库特性","permalink":"https://chensnape.github.io/tags/数据库特性/"}],"keywords":[{"name":"oracle","slug":"oracle","permalink":"https://chensnape.github.io/categories/oracle/"}]},{"title":"4子查询、多表查询","slug":"4子查询、多表查询","date":"2019-09-16T09:16:24.000Z","updated":"2019-09-16T03:13:45.839Z","comments":true,"path":"2019/09/16/4子查询、多表查询/","link":"","permalink":"https://chensnape.github.io/2019/09/16/4子查询、多表查询/","excerpt":"","text":"子查询、多表查询2019/9/3 15:36:14 select查询语句(重中之重、难点)子查询子查询就是指将一个查询语句的结果作为另外一个查询语句条件的方式，又叫做多次/多重查询，也就是查询语句中嵌套着另外一个查询语句。 查询语句的语法格式： select [distinct] 字段名1 [as 别名1], 字段名2 [as 别名2], ... from 表名 [where 条件表达式] [group by 字段名] [having 条件表达式] [order by 字段名/别名/位置编号 asc/desc];123456789101112131415-- 查询学生表中年龄比'崔今生'小的学生信息，也就是出生日期比'崔今生'大的学生-- 该需求涉及到student学生表-- 涉及的字段有：borndate出生日期, studentname学生姓名-- 第一步：先查询学生表中'崔今生'的出生日期 '1990-01-05'select to_char(borndate, 'yyyy-mm-dd') 出生日期 from studentwhere studentname = '崔今生';-- 第二步：再查询学生表中出生日期大于'崔今生'出生日期的学生信息select to_char(borndate, 'yyyy-mm-dd') 出生日期 from studentwhere borndate &gt; to_date('1990-01-05', 'yyyy-mm-dd'); -- 合并起来使用子查询一步到位select to_char(borndate, 'yyyy-mm-dd') 出生日期 from studentwhere borndate &gt; (select borndate from student where studentname = '崔今生'); 练习：123456789101112131415-- 查询学生表中与'崔今生'在同一个年级的学生信息-- 该需求涉及到student学生表-- 涉及到的字段有：gradeid年级编号, studentname学生姓名-- 第一步：查询'崔今生'所在的年级编号 1select gradeid from studentwhere studentname = '崔今生';-- 第二步：再查询与'崔今生'所在年级编号一样的学生信息select studentname, gradeid from studentwhere gradeid = 1; -- 合并为子查询一步到位select studentname, gradeid from studentwhere gradeid = ( select gradeid from student where studentname = '崔今生' ); 案例分析：123456789101112131415161718192021222324252627-- 查询'JavaSE'课程并且考试成绩为100分的学生信息-- 该需求涉及到：subject课程表， result成绩表, student学生表-- 其中subject课程表和result成绩表之间采用： subjectid课程编号关联 根据课程表中的名称可以查询到课程编号，根据课程编号可以查询到考试成绩-- 其中result成绩表和student学生表之间采用：studentno学号关联 根据考试成绩可以查询到学生编号，根据学生编号可以查到学生信息-- 该需求涉及到的字段： subject课程表中字段: subjectname课程名称、subjectid课程编号 result成绩表中字段： studentresult学生成绩、subjectid课程编号、studentno学生编号 student学生表中字段：studentno学生编号-- 第一步：根据课程的名称查询对应的课程编号 1select subjectid from subjectwhere subjectname = 'JavaSE';-- 第二步：根据课程的编号查询对应的考试成绩 根据考试成绩100和课程编号共同来查询学生的编号 'S1101019'select studentno from resultwhere subjectid = 1 and studentresult = 100;-- 第三步：根据学生的编号来得到学生的信息select studentname from studentwhere studentno = 'S1101019'; -- 合并为子查询的查询语句select studentname from studentwhere studentno = ( select studentno from result where subjectid = ( select subjectid from subject where subjectname = 'JavaSE') and studentresult = 100 ); 练习：123456789101112131415161718192021222324252627282930313233343536-- 查询“青铜”阶段开设的课程-- 该需求涉及到：grade年级表 和 subject课程表-- 其中grade年级表和subject课程表之间采用 gradeid年级编号 进行关联-- 第一步：先查询'青铜'对应的年级编号 1select gradeid from gradewhere gradename = '青铜';-- 第二步：再根据年级编号查询对应的课程名称select subjectname from subjectwhere gradeid = 1;-- 合并为子查询select subjectname from subjectwhere gradeid = ( select gradeid from grade where gradename = '青铜' ); -- 查询参加最近一次“HTML和CSS网页技术”考试成绩的学生的最高分和最低分-- 该需求涉及到：subject课程表 和 result成绩表-- 其中课程表和成绩表之间采用 subjectid课程编号 进行关联-- 第一步：查询'HTML和CSS网页技术'对应的课程编号 2select subjectid from subjectwhere subjectname = 'HTML和CSS网页技术';-- 第二步：查询课程编号对应的最近一次考试成绩，也就是考试日期最大的一次-- '2010-03-01'select max(examdate) from resultwhere subjectid = 2;-- 第三步：查询课程编号对应的考试成绩，并求出最高分和最低分select max(studentresult) 最高分, min(studentresult) 最低分 from resultwhere subjectid = 2 and examdate = to_date('2010-03-01', 'yyyy-mm-dd');-- 合并为子查询select max(studentresult) 最高分, min(studentresult) 最低分 from resultwhere subjectid = ( select subjectid from subject where subjectname = 'HTML和CSS网页技术') and examdate = ( select max(examdate) from result where subjectid = ( select subjectid from subject where subjectname = 'HTML和CSS网页技术' ) ); 案例讲解：12345678910111213141516171819202122232425-- 查询'JavaSE'课程所有考试成绩不及格的学员名单-- 该需求涉及到： subject课程表 result成绩表 student学生表-- 其中subject课程表和result成绩表之间采用 subjectid课程编号 关联-- 其中result成绩表和student学生表之间采用 studentno学号 关联-- 第一步：根据课程名称查询课程编号 1select subjectid from subjectwhere subjectname = 'JavaSE';-- 第二步：根据课程编号和不及格的考试成绩来查询对应的学号 -- S1200902002 S1101004 S1101010 S1101013 select studentno from resultwhere subjectid = 1 and studentresult &lt; 60; -- 第三步：根据学号查询学生名单select studentname from studentwhere studentno in ('S1200902002','S1101004','S1101010','S1101013');-- 合并为子查询select studentname from studentwhere studentno in (select studentno from result where subjectid = ( select subjectid from subject where subjectname = 'JavaSE') and studentresult &lt; 60);-- 当子查询的结果为多个时，可以使用in 或者使用 anyselect studentname from studentwhere studentno = any (select studentno from result where subjectid = ( select subjectid from subject where subjectname = 'JavaSE') and studentresult &lt; 60); 案例讲解：1234567891011121314-- 查询'JavaSE'课程最近一次考试的在读学生名单-- 该需求涉及到：subject课程表 result成绩表 student学生表-- 其中subject课程表和result成绩表之间采用 subjectid课程编号 关联-- 其中result成绩表和student学生表之间采用 studentno学号 关联-- 根据课程名称查询到课程编号，根据课程编号和最近一次考试的日期来查询学号-- 根据学号来查询学生表中学生姓名select studentname from studentwhere studentno in ( select studentno from result where examdate = ( select max(examdate) from result where subjectid = ( select subjectid from subject where subjectname = 'JavaSE')) and subjectid = ( select subjectid from subject where subjectname = 'JavaSE')); 多表查询单表查询 - 主要指select查询语句中from关键字后面只跟一个表名的形式 多表查询 - 主要指select查询语句中from关键字后面跟着多个表名的形式 - 也就是说同时查询的数据来自于多张表 (1)内连接 所谓内连接就是指使用两张表都有的字段和关系运算符进行匹配，从而得到两张表都有数据内容组成的结果集。 内连接的语法格式一(老版)： select [表名1.]字段名1, [表名2.]字段名2, ... from 表名1 [别名1], 表名2 [别名2], ... where 表之间的关联条件; 内连接的语法格式二(新版): select [表名1.]字段名1, [表名2.]字段名2, ... from 表名1 [别名1] inner join 表名2[别名2] on 表之间的关联条件;1234567891011121314-- 查询学生的学号、学生的名字以及学生的考试成绩-- 该需求涉及到：student学生表 result成绩表-- 其中student学生表和result成绩表之间采用 studentno学号 关联-- studentno学号是两张表共有的字段，也就是通用列-- studentname学生名称是 student学生表中的字段-- studentresult学生成绩是 result成绩表中的字段-- 等值连接select student.studentno, studentname, studentresult from student, resultwhere student.studentno = result.studentno;-- 新版本的写法select student.studentno, studentname, studentresult from student inner join resulton student.studentno = result.studentno; 12345678-- 当内连接忘记指定表之间的关联条件时，得到 5456 条记录 笛卡尔成绩-- 就是该方式会使用第一张表中的每一条数据与第二张表中的每一条数据都组合一次select student.studentno, studentname, studentresult from student, result;-- 查询student表中的所有数据 62条select * from student;-- 查询result表中的所有数据 88条select * from result; 练习：12345678910111213141516-- 查询员工编号，姓名以及所在部门名称-- 该需求涉及到：s_emp员工表 和 s_dept部门表-- 两张表之间采用 部门编号 进行关联-- 其中员工编号id 和 员工姓名last_name和first_name 来自于员工表-- 其中部门名称name 来自于部门表select s_emp.id, last_name||first_name, name from s_emp inner join s_depton s_emp.dept_id = s_dept.id; -- 查询部门编号以及该部门负责的区域名称-- 该需求涉及到： s_dept部门表 和 s_region区域表-- 两张表之间采用 区域编号 进行关联-- 其中部门编号id来自于s_dept部门表-- 其中区域名称name来自于s_region区域表select s_dept.id, s_region.name from s_dept inner join s_regionon s_dept.region_id = s_region.id; 案例讲解：12345678910111213141516-- 查询学生名称、课程名称以及考试成绩-- 该需求涉及到：student学生表、 subject课程表、result成绩表-- 其中student学生表 和 result成绩表之间采用 学号studentno 进行关联-- 其中result成绩表 和 subject课程表之间采用 课程编号subjectid进行关联-- 其中学生名称studentname来自于student学生表-- 其中课程名称subjectname来自于subject课程表-- 其中考试成绩studentresult来自于result成绩表select studentname, subjectname, studentresult from (student inner join result on student.studentno = result.studentno) inner join subject on result.subjectid = subject.subjectid;-- 老版本的写法select studentname, subjectname, studentresultfrom student, result, subjectwhere student.studentno = result.studentno and result.subjectid = subject.subjectid; 作业：-- 查询和Ben一个部门的员工的id，first_name,dept_id,salary信息 -- 显示所有工资超过Ben的员工的信息，包括：id,first_name,salary -- 显示工资高于全公司平均工资的员工信息，包括id,first_name,salary -- 显示工资高于部门id=43的平均工资 的员工信息，包括id,first_name,salary -- 显示所有工资等于 部门43的所有员工 的信息，包括id,first_name,salary -- 返回管理者的信息，id,first_name,salary，也就是id号和manager_id相同 -- 显示所有工资大于 部门43的任意员工 的信息，包括id,first_name,salary -- 显示平均工资 比部门id=33高的 部门id和平均工资 -- 查询员工编号、员工姓名、员工薪水、薪水等级 -- 查询员工编号、员工姓名、领导编号、领导姓名 -- 查询年级编号为1的年级名称、科目名称及学时 -- 查询学生学号、姓名、考试科目名称及成绩 -- 查询参加“JavaSE”考试的学生姓名、成绩、考试日期","categories":[{"name":"oracle","slug":"oracle","permalink":"https://chensnape.github.io/categories/oracle/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"https://chensnape.github.io/tags/oracle/"},{"name":"子查询、多表查询","slug":"子查询、多表查询","permalink":"https://chensnape.github.io/tags/子查询、多表查询/"}],"keywords":[{"name":"oracle","slug":"oracle","permalink":"https://chensnape.github.io/categories/oracle/"}]},{"title":"3select高级查询","slug":"3select高级查询","date":"2019-09-16T09:12:54.000Z","updated":"2019-09-16T03:11:50.477Z","comments":true,"path":"2019/09/16/3select高级查询/","link":"","permalink":"https://chensnape.github.io/2019/09/16/3select高级查询/","excerpt":"","text":"select高级查询2019/9/3 15:19:13 select查询语句(重中之重)复习一下select查询的格式select [distinct] 字段名1 [别名1], 字段名2 [别名2], ... from 表名 [where 条件];字段的排序select [distinct] 字段名1 [别名1], 字段名2 [别名2], ... from 表名 [where 条件] [order by 字段名/别名/位置编号 asc/desc];1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768-- 查询员工表中所有员工的名字和薪水，并按照薪水进行升序排列select first_name, salary from s_emporder by salary asc;-- asc可以省略，默认就是从小到大的升序排序select first_name, salary from s_emporder by salary;-- 查询员工表中所有员工的姓和薪水，并按照姓进行升序排列 -- 空值排列在最后select last_name, salary from s_emporder by last_name;-- 查询员工表中所有员工的姓和薪水，并按照姓进行降序排列select last_name, salary from s_emporder by last_name desc;-- 经验分享：当降序排列时空值默认在最前面影响用户体验度，应该放在后面select last_name, salary from s_emporder by last_name desc nulls last;-- 查询员工表中薪水小于1000的所有员工薪水并进行去重处理-- 再按照薪水进行降序排列select distinct salary \"薪 水\" from s_empwhere salary &lt; 1000order by salary desc; -- 查询员工表中所有员工的名字和薪水，将薪水起别名为Income，并按照别名降序select first_name, salary \"Income\" from s_emporder by \"Income\" desc;-- 查询员工表中所有员工加上奖金后的年薪，别名为\"年 薪\"，并按照年薪升序select first_name, salary, (salary+nvl(commission_pct,0))*16 \"年 薪\"from s_emporder by \"年 薪\" asc;-- 查询员工表中所有员工的姓名，别名为\"name\"，并按照name进行降序排列select last_name||first_name \"name\" from s_emporder by \"name\" desc;-- 常见的考点：本质上根本没有排序select last_name||first_name \"name\" from s_emporder by 'name' desc;-- 查询员工表中所有员工的姓和薪水信息，并按照位置编号0进行升序排序-- Error: sql语句中下标通常都是从1开始select last_name, salary from s_emporder by 0 asc;-- 表示按照位置编号1开始排序，也就是按照last_name排序select last_name, salary from s_emporder by 1 asc;-- 表示按照位置编号2开始排序，也就是按照salary排序select last_name, salary from s_emporder by 2 asc;-- 表示按照位置编号3开始排序 Error：位置编号必须在select列表范围select last_name, salary from s_emporder by 3 asc;-- 增加一个查询的信息select last_name, salary, salary*16 \"年 薪\" from s_emporder by 3 asc;-- 查询员工表中所有员工的部门编号、薪水以及编号，要求按照部门编号进行降序select dept_id, salary, id from s_emporder by dept_id desc;-- 查询员工表中所有员工的部门编号、薪水以及编号，部门编号降序，薪水降序-- desc只对挨着的字段好使，若需要多个字段分别排序就需要单独加desc等-- salary后面没有asc也没有desc，当部门编号相同时，薪水默认按照升序排列select dept_id, salary, id from s_emporder by dept_id desc, salary;select dept_id, salary, id from s_emporder by dept_id desc, salary desc;-- 查询员工表中所有员工的部门编号、薪水以及编号-- 部门编号降序，薪水降序，员工编号升序select dept_id, salary, id from s_emporder by dept_id desc, salary desc, id asc; 常用的字符串函数12345678910111213141516171819202122-- 查询字符串的长度select length('hello') 计算字符串的长度 from dual; -- 5-- 实现将字符串所有字符串转换为大写select upper('hello') 将字符串转换为大写 from dual; -- HELLO-- 实现将字符串所有字符转换为小写select lower('HELLO') 将字符串转换为小写 from dual; -- hello-- 实现将字符串中首字母转换为大写select initcap('hello') 首字母转换为大写 from dual; -- Hello-- 实现字符串中内容的截取，表示从下标2开始截取3个字符，下标从1开始select substr('hello', 2, 3) 截取字符串 from dual; -- ell-- 实现两个字符串之间的拼接select concat('hello', 'world') 拼接字符串 from dual; -- helloworld-- 实现字符串中内容的替换，表示将'e'替换为'E'select replace('hello', 'e', 'E') 替换字符串 from dual; -- hEllo-- 实现字符串中内容的替换，全部替换select replace('hehe', 'e', 'E') 替换字符串 from dual; -- hEhE-- 实现字符串中子字符串第一次出现的索引位置select instr('hello', 'e') 查找下标 from dual; -- 2-- 实现字符串中前后两端空白字符的去除select trim(' hello ') 去除两端空白 from dual; -- helloselect length(trim(' hello ')) 去除两端空白 from dual; -- 5 常用的数值函数1234567891011121314151617181920212223242526-- 实现数值18.56789后保留3位小数并进行四舍五入的功能select round(18.56789, 3) 保留3位小数 from dual; -- 18.568-- 实现数值18.54789后保留2位小数并进行四舍五入的功能select round(18.54789, 2) 保留2位小数 from dual; -- 18.55-- 实现数值18.54789后保留1位小数并进行四舍五入的功能select round(18.54789, 1) 保留1位小数 from dual; -- 18.5-- 实现数值18.54789后保留0位小数并进行四舍五入的功能select round(18.54789, 0) 保留0位小数 from dual; -- 19-- 实现数值18.54789后保留-1位小数并进行四舍五入的功能select round(18.54789, -1) \"保留-1位小数\" from dual; -- 20-- 实现数值18.54789后保留-2位小数并进行四舍五入的功能select round(18.54789, -2) \"保留2位小数\" from dual; -- 0-- 实现数值18.56789后保留3位小数并进行截取的功能select trunc(18.56789, 3) 保留3位小数 from dual; -- 18.567-- 实现数值18.54789后保留2位小数并进行截取的功能select trunc(18.54789, 2) 保留2位小数 from dual; -- 18.54-- 实现数值18.54789后保留1位小数并进行截取的功能select trunc(18.54789, 1) 保留1位小数 from dual; -- 18.5-- 实现数值18.54789后保留0位小数并进行截取的功能select trunc(18.54789, 0) 保留0位小数 from dual; -- 18-- 实现数值18.54789后保留-1位小数并进行截取的功能select trunc(18.54789, -1) \"保留-1位小数\" from dual; -- 10-- 实现数值18.54789后保留-2位小数并进行截取的功能select trunc(18.54789, -2) \"保留-2位小数\" from dual; -- 0 常用的日期函数to_char函数主要用于将数据中的日期类型数据获取出来并转换为字符串类型显示出来 to_date函数主要用于将字符串类型的日期数据转换为日期类型数据再插入到数据库12345678910111213141516171819202122232425262728293031323334353637383940-- 查询当前的系统时间select sysdate from dual;-- 查询当前系统时间对应的昨天select sysdate-1 from dual;-- 查询当前系统时间对应的前天select sysdate-2 前天 from dual;-- 查询当前系统时间对应的明天select sysdate+1 明天 from dual;-- 查询当前的系统时间并按照年月日时分秒的格式显示出来select to_char(sysdate, 'yyyy-mm-dd hh24:mi:ss') 当前系统时间 from dual;-- 查询员工表中所有员工的入职日期并按照年月日显示出来select to_char(start_date, 'yyyy-mm-dd') 入职日期 from s_emp;-- 向员工表中插入'常宏'的信息并指定入职日期为当前系统时间insert into s_emp (id, last_name, first_name, start_date) values(27, '常', '宏', sysdate);-- 向员工表中插入'张衡'的信息并指定入职日期为当前系统时间insert into s_emp (id, last_name, first_name, start_date) values(28, '张', '衡', to_date('2019-08-30', 'yyyy-mm-dd'));-- 查询当前系统时间的下一个月select to_char(add_months(sysdate, 1), 'yyyy-mm-dd') 下一个月 from dual;-- 查询当前系统时间的下两个月select to_char(add_months(sysdate, 2), 'yyyy-mm-dd') 下两个月 from dual;-- 查询当前系统时间的上一个月select to_char(add_months(sysdate, -1), 'yyyy-mm-dd') 上一个月 from dual;-- 查询当前系统时间的上两个月select to_char(add_months(sysdate, -2), 'yyyy-mm-dd') 上两个月 from dual;-- 查询当前系统时间加1个月加1天加1小时加1分-- add_months函数返回的是日期类型，也就是date类型select to_char((add_months(sysdate, 1) + 1 + 1/24 + 1/24/60), 'yyyy-mm-dd hh24:mi:ss') from dual;-- 查询当前系统时间，并按照dd进行截取然后转换为字符串显示-- 保留到dd，dd后面的时分秒全部丢弃select to_char(trunc(sysdate, 'dd'), 'yyyy-mm-dd hh24:mi:ss') 按天截取 from dual;-- 查询当前系统时间，并按照mm进行截取然后转换为字符串显示select to_char(trunc(sysdate, 'mm'), 'yyyy-mm-dd hh24:mi:ss') 按月截取 from dual;-- 查询当前系统时间，并按照yyyy进行截取然后转换为字符串显示select to_char(trunc(sysdate, 'yyyy'), 'yyyy-mm-dd hh24:mi:ss') 按年截取 from dual; 练习讲解：12345678910111213141516-- 求当前月份的最后一分钟0秒表示的date数据-- 2019-8-31 23:59:00select to_char(trunc(add_months(sysdate,1), 'mm') - 1/24/60, 'yyyy-mm-dd hh24:mi:ss') 本月最后一分钟from dual;-- 求下个月的第三天的倒数十分钟0秒表示的date数据-- 2019-9-03 23:50:00select to_char(trunc(add_months(sysdate,1), 'mm') + 3 - 1/24/60*10, 'yyyy-mm-dd hh24:mi:ss') 下个月第三天from dual; -- 查询s_emp表格(id,last_name,start_date),按照start_date排序 , -- 查询的条件为: 入职日期在2018年1月1日 到2018年12月31日select id, last_name, start_date from s_empwhere start_date between to_date('2018-01-01', 'yyyy-mm-dd') and to_date('2018-12-31', 'yyyy-mm-dd')order by start_date; 常用的聚合(多行)函数单行函数 - 主要是将单条数据内容传入给该函数处理后的结果还是单条数据内容. 聚合(多行)函数 - 主要是将多条数据内容输入该函数处理后的结果是单条数据内容。 常用的聚合函数： sum() - 主要用于实现多条数据累加和的计算，只能用于数值类型。 avg() - 主要用于实现多条数据平均值的计算，只能用于数值类型。 max() - 主要用于实现多条数据最大值的计算，可以处理任意类型的数据。 min() - 主要用于实现多条数据最小值的计算，可以处理任意类型的数据。 count() - 主要用于实现多条记录统计个数的计算，通常使用count(*)来实现。12345678910111213-- 查询员工表中所有员工的总薪水select sum(salary) 总薪水 from s_emp;-- 查询员工表中所有员工的平均薪水，要求采用四舍五入保留两位小数select round(avg(salary), 2) 平均薪水 from s_emp;-- 查询员工表中所有员工的平均奖金，要求采用四舍五入保留两位小数select round(avg(nvl(commission_pct,0)), 2) 平均奖金 from s_emp;-- 查询员工表中所有员工的最高薪水select max(salary) 最高薪 from s_emp; -- 查询员工表中所有员工的最低薪水select min(salary) 最低新 from s_emp;-- 查询员工表中员工的个数select count(*) 员工数量 from s_emp; 练习：123456789101112131415-- 查询员工表中资历最老的员工并显示入职日期select to_char(min(start_date), 'yyyy-mm-dd') 资历最老 from s_emp;-- 查询员工表中资历最小的员工并显示入职日期select to_char(max(start_date), 'yyyy-mm-dd') 资历最小 from s_emp;-- 查询成绩表中所有学生的总成绩select sum(studentresult) 总成绩 from result;-- 查询成绩表中所有学生的平均成绩select round(avg(studentresult), 2) 平均成绩 from result;-- 查询成绩表中所有学生的最高分select max(studentresult) 最高分 from result;-- 查询成绩表中所有学生的最低分select min(studentresult) 最低分 from result;-- 查询学生表中所有学生的人 select count(*) from student; 分组查询select [distinct] 字段名1 [别名1], 字段名2 [别名2], ... from 表名 [where 条件] [group by 字段名] [order by 字段名/别名/位置编号 asc/desc];12345678910111213141516171819-- 查询学生表中每个年级的总人数并显示出来，每...就表示按照...分组select gradeid 年级编号, count(*) 总人数 from studentgroup by gradeid; -- 查询学生表中每种性别的总人数并显示出来select sex 性别, count(*) 总人数 from studentgroup by sex;-- 查询学生表中每个年级的总人数并显示出来，要求按照年级总人数降序排列select gradeid 年级编号, count(*) 总人数 from studentgroup by gradeidorder by count(*) desc;select gradeid 年级编号, count(*) 总人数 from studentgroup by gradeidorder by 总人数 desc;-- 查询学生表中每个年级的总人数并显示出来，显示学生编号、年级编号、总人数-- Error:studentno不能出现在select列表中-- select列表中只能出现分组的字段以及聚合函数select studentno, gradeid, count(*) from studentgroup by gradeid; 练习：123456789101112131415161718-- 查询成绩表中每门课程的平均分并显示出来，要求平均分保留2位小数select subjectid 课程编号, round(avg(studentresult), 2) 平均分 from resultgroup by subjectid;-- 查询成绩表中每门课程的平均分并显示出来，要求按照平均分进行降序排列select subjectid 课程编号, round(avg(studentresult), 2) 平均分 from resultgroup by subjectidorder by 平均分 desc;-- 查询学生表中每个年级男女同学的人数并显示出来select gradeid 年级编号, sex 性别, count(*) 人数 from studentgroup by gradeid, sex; -- 查询学生表中每个年级男女同学的人数并按照年级升序select gradeid 年级编号, sex 性别, count(*) 人数 from studentgroup by gradeid, sexorder by gradeid asc; 分组之后的再次过滤select [distinct] 字段名1 [别名1], 字段名2 [别名2], ... from 表名 [where 条件] [group by 字段名] [having 条件] [order by 字段名/别名/位置编号 asc/desc]; 12345678910-- 查询每个年级的总人数且总人数要超过18人的才显示出来-- Error: where子句中不能出现聚合函数select gradeid 年级编号， count(*) 总人数 from studentwhere count(*) &gt; 18group by gradeid;select gradeid 年级编号， count(*) 总人数 from studentgroup by gradeidhaving count(*) &gt; 18; 总结select查询语句一般的执行流程： from 表名 =&gt; where子句进行过滤 =&gt; group by子句进行分组 =&gt; having子句进行再次过滤 =&gt; select将数据取出来 =&gt; order by子句对取出来进行排序练习：12345678910111213141516171819-- 查询每个年级的总课时，并升序排列 （subject表）select gradeid 年级编号, sum(classhour) 总课时 from subjectgroup by gradeidorder by 总课时 asc;-- 查询每个学员的平均分（result表）select studentno 学号编号， avg(studentresult) 平均分 from resultgroup by studentno;-- 查询每门课程的平均分，并降序排列（result表）select subjectid 课程编号, round(avg(studentresult), 2) 平均分 from resultgroup by subjectidorder by 平均分 desc;-- 查询每个学生的总分，并降序排列（result表）select studentno 学生编号, sum(studentresult) 总分 from resultgroup by studentnoorder by 总分 desc; 作业：查询成绩表中学生编号、课程编号以及学生成绩信息，要求按照学生编号进行降序排列，若学生编号一样 按照课程编号降序，若课程编号一样按照成绩升序排序 查询s_emp表中所有first_name包含b或B的员工，显示id、first_name、salary信息 显示s_emp表中first_name中4个字符以后的内容 查询今天过生日的员工信息，假设入职日期就是出生日期","categories":[{"name":"oracle","slug":"oracle","permalink":"https://chensnape.github.io/categories/oracle/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"https://chensnape.github.io/tags/oracle/"},{"name":"高级查询","slug":"高级查询","permalink":"https://chensnape.github.io/tags/高级查询/"}],"keywords":[{"name":"oracle","slug":"oracle","permalink":"https://chensnape.github.io/categories/oracle/"}]},{"title":"2select查询基础","slug":"2select查询基础","date":"2019-09-16T09:09:21.000Z","updated":"2019-09-16T03:11:11.755Z","comments":true,"path":"2019/09/16/2select查询基础/","link":"","permalink":"https://chensnape.github.io/2019/09/16/2select查询基础/","excerpt":"","text":"select查询基础2019/9/3 14:33:28 select查询语句(重中之重)查看表结构 desc 表名; desc s_emp; - 表示查看s_emp(员工表)表中的结构 名称 空值 类型 -------------- -------- ------------- ID NOT NULL NUMBER(7) -- 员工的编号 LAST_NAME VARCHAR2(25) -- 员工的姓 FIRST_NAME VARCHAR2(25) -- 员工的名字 USERID VARCHAR2(8) -- 员工的昵称 START_DATE DATE -- 入职日期 COMMENTS VARCHAR2(255) -- 备注信息 MANAGER_ID NUMBER(7) -- 领导的编号 TITLE VARCHAR2(25) -- 员工的职位 DEPT_ID NUMBER(7) -- 部门的编号 SALARY NUMBER(11,2) -- 员工的薪水 COMMISSION_PCT NUMBER(4,2) -- 员工的奖金 desc s_dept; -- 表示查看s_dept(部门表)表中的结构 名称 空值 类型 --------- -------- ------------ ID NOT NULL NUMBER(7) -- 部门编号 NAME NOT NULL VARCHAR2(25) -- 部门名称 REGION_ID NUMBER(7) -- 区域编号 desc s_region; -- 表示查看s_region(区域表)表中的结构 名称 空值 类型 ---- -------- ------------ ID NOT NULL NUMBER(7) -- 区域编号 NAME VARCHAR2(50) -- 区域名称 desc salgrade -- 表示查看salgrade(薪水等级表)表中的结构 名称 空值 类型 ----- -------- --------- GRADE NOT NULL NUMBER(7) -- 薪水等级 LOSAL NUMBER(7) -- 最低薪水 HISAL NUMBER(7) -- 最高薪水字段的查询select 字段名1, 字段名2,... from 表名;123456789101112 -- 查询员工表中所有员工的编号信息, 共25个员工select id from s_emp;-- 查询员工表中所有员工的编号、名字select id, first_name from s_emp; -- 查询员工表中所有员工的编号、名字、薪水，最高薪水2500，最低750select id, first_name, salary from s_emp;-- 查询员工表中所有员工的编号、姓、名字、...等所有字段select id, last_name, first_name,USERID, START_DATE, COMMENTS, MANAGER_ID, TITLE, DEPT_ID, SALARY, COMMISSION_PCT from s_emp;-- 查询员工表中所有字段的信息select * from s_emp; 常用的算术运算符+ 加法 - 减法 * 乘法 / 除法 mod() 取余12345678910111213-- 查询员工表中所有员工加上500元过节费后的薪水select salary, salary+500 from s_emp;-- 查询员工表中所有员工降薪100元后的薪水select salary, salary-100 from s_emp;-- 查询员工表中所有员工的年薪，一年16个薪水 select salary, salary*16 from s_emp;-- 查询员工表中所有员工的日薪，一个月按照22天计算select salary, salary/22 from s_emp;-- 查询员工表中所有员工涨薪200元后的年薪select salary, (salary+200)*16 from s_emp;-- 使用取余运算select mod(9, 2) from s_emp; 列的别名select 字段名1 [as] 别名1, 字段名2 [as] 别名2, ... from 表名;12345678910111213-- 查询员工表中所有员工的薪水和年薪，并将年薪起别名为yearsalaryselect salary, salary*16 as yearsalary from s_emp;-- 其中as可以省略select salary, salary*16 yearsalary from s_emp;-- error: 遇到空格认为别名已经结束，此时应该跟fromselect salary, salary*16 year salary from s_emp;-- 当别名中有空格时，则可以使用\"\"括起来看做整体作为别名select salary, salary*16 \"year salary\" from s_emp;-- 希望将别名中每个单词的首字母大写select salary, salary*16 \"Year Salary\" from s_emp;-- 实现常量列的查询select '兄弟连' 学校的名称 from s_emp; 注意： a.当别名中有空格或者需要区分大小写时，就需要使用&quot;&quot;括起来作为整体； b.sql语句本身不区分大小写，但&apos;&apos;和&quot;&quot;中的内容是区分大小写的 字符串的拼接|| 用于实现字符串的拼接，相当于Java语言中+运算符。123456789101112131415161718-- 查询员工表中所有员工的姓以及名字select last_name, first_name from s_emp; -- 查询员工表中所有员工的姓名，将起别名为\"Name\"select last_name||first_name \"Name\" from s_emp;-- 查询员工表中所有员工的姓名，姓和名之间采用-连接，起别名为\"姓名\"select last_name||'-'||first_name 姓名 from s_emp;-- 查询员工表中所有员工的姓名，采用_连接select last_name||'_'||first_name 姓名 from s_emp;-- 查询员工表中所有员工的姓名，采用'连接-- Error: '除了表示本身的含义之外，还具有字符串开头和结尾标志的含义select last_name||'''||first_name 姓名 from s_emp; -- errorselect last_name||'\\''||first_name 姓名 from s_emp; -- error:Java中转义字符-- ' 就是转义字符 '' 表示打印一个'select last_name||''''||first_name 姓名 from s_emp;-- 希望使用''进行连接select last_name||''''''||first_name 姓名 from s_emp;select last_name||''''||''''||first_name 姓名 from s_emp; where子句select 字段名1 [as] 别名1, 字段名2 [as] 别名2, ... from 表名 [where 条件];常用的比较运算符&gt; 大于 &gt;= 大于等于 &lt; 小于 &lt;= 小于等于 = 等于 &lt;&gt; 不等于 注意： 在sql语句中没有赋值的概念，只有=表示等于的含义。12345678910111213-- 查询员工表中薪水大于2000的员工名字以及员工薪水select first_name, salary from s_empwhere salary &gt; 2000;-- 查询员工表中薪水大于等于800的员工名字以及员工薪水select first_name, salary from s_empwhere salary &gt;= 800;-- 查询员工表中薪水等于1400的员工名字以及员工薪水,3个员工select first_name, salary from s_empwhere salary = 1400;-- 查询员工表中薪水不等于1400的员工名字以及员工薪水select first_name, salary from s_empwhere salary &lt;&gt; 1400; 逻辑运算符and 并且 or 或者 not 非123456789101112131415161718192021222324252627-- 查询员工表中薪水超过1000并且部门编号为42号的员工名称、薪水以及部门编号select first_name, salary, dept_id from s_empwhere salary &gt; 1000 and dept_id = 42;-- 查询员工表中薪水超过1000或者部门编号为42号的员工名称、薪水以及部门编号select first_name, salary, dept_id from s_empwhere salary &gt; 1000 or dept_id = 42;-- 查询员工表中薪水超过1000但部门编号不是42的员工名称、薪水以及部门编号select first_name, salary, dept_id from s_empwhere salary &gt; 1000 and dept_id &lt;&gt; 42;-- 使用not运算符select first_name, salary, dept_id from s_empwhere salary &gt; 1000 and not dept_id = 42;-- 查询员工表中薪水超过800并且部门编号是41或者42的员工名称、薪水及部门编号-- 下面的查询结果不满足要求select first_name, salary, dept_id from s_empwhere salary &gt; 800 and dept_id = 41 or dept_id = 42;-- and运算符的优先级高于orselect first_name, salary, dept_id from s_empwhere salary &gt; 800 and (dept_id = 41 or dept_id = 42);-- 尝试一下极限条件 条件永远为真，条件与表中数据无关，查询到全部数据select * from s_emp where 1 = 1; -- 条件永远为假， 没有查询到任何数据-- 执行次序：执行from表名 =&gt; 执行where =&gt; 执行select数据select * from s_emp where 1 &lt;&gt; 1; 注意： a. and运算符的优先级高于or，因此若希望先执行or运算时可以使用()来提高优先级 b. where子句的执行次序是从右向左执行的，因此建议如下： 对于and运算符来说，应该将为假的可能性更高的条件放在右边; 对于or运算符来说，应该将为真的可能性更高的条件放在右边;按照范围进行查询between ... and ... 表示在...和...之间，闭区间12345678910111213141516171819202122232425-- 查询员工表中薪水范围在800到1400之间的员工名称以及员工薪水select first_name, salary from s_emp where salary between 800 and 1400;-- 等价的写法select first_name, salary from s_empwhere salary &gt;= 800 and salary &lt;= 1400;-- 非等价的写法select first_name, salary from s_empwhere salary &gt; 800 and salary &lt; 1400;-- 查询员工表中薪水范围不在800和1400之间的员工名称以及员工薪水select first_name, salary from s_empwhere salary &lt; 800 or salary &gt; 1400; -- 等价的写法select first_name, salary from s_empwhere salary not between 800 and 1400;-- 笔试考点-- 没有报错，但也查询不到任何数据select first_name, salary from s_empwhere salary between 1400 and 800;-- 没有报错，但查询不到任何数据select first_name, salary from s_empwhere salary &gt;= 1400 and salary &lt;= 800; 练习：123456789101112131415161718192021-- 查询员工表中名字为'Ben'的员工名称以及员工薪水select first_name, salary from s_empwhere first_name = 'Ben';-- 下面的写法查询不到，''内部区分大小写select first_name, salary from s_empwhere first_name = 'ben';-- 查询员工表中奖金不为空的员工名称、员工薪水以及奖金信息-- 查询不到数据select first_name, salary, commission_pct from s_empwhere commission_pct &lt;&gt; null;-- 查询员工表中奖金为空的员工名称、员工薪水以及奖金信息-- 查询不到数据select first_name, salary, commission_pct from s_empwhere commission_pct = null;-- 查询员工表中加上奖金后的员工名称、员工薪水以及奖金信息-- 查询结果不正确select first_name, salary, commission_pct,salary+commission_pct from s_emp; 空值的处理is null - 判断是否为空 is not null - 判断是否不为空12345678910111213-- 查询员工表中奖金不为空的员工名称、员工薪水以及奖金信息select first_name, salary, commission_pct from s_empwhere commission_pct is not null;select first_name, salary, commission_pct from s_empwhere not commission_pct is null;-- 下面的写法语法错误select first_name, salary, commission_pct from s_empwhere commission_pct not is null; -- 查询员工表中奖金为空的员工名称、员工薪水以及奖金信息select first_name, salary, commission_pct from s_empwhere commission_pct is null; 由于空值和任何数据运算的结果还是空值，因此需要使用nvl函数加以处理，具体： nvl(参数1, 参数2) - 若参数1不为空则使用参数1的数值，否则使用参数2的数值1234-- 查询员工表中加上奖金后的员工名称、员工薪水以及奖金信息select first_name, salary, commission_pct,salary+nvl(commission_pct,0) from s_emp; 数据的去重select [distinct] 字段名1 [as] 别名1, 字段名2 [as] 别名2, ... from 表名 [where 条件];12345678910111213141516-- 查询员工表中薪水超过1000元的所有员工名称以及薪水信息，18条记录select first_name, salary from s_empwhere salary &gt; 1000;-- 查询员工表中薪水超过1000元的所有员工薪水信息，要求薪水不能重复select distinct salary from s_empwhere salary &gt; 1000;-- 查询员工表中所有部门的编号，要求去重select distinct dept_id from s_emp;-- 查询员工表中所有员工的薪水和部门编号select salary, dept_id from s_emp;-- 查询员工表中所有员工的薪水和部门编号，要求按照薪水和部门编号去重-- 当多个字段都相同时才能去重select distinct salary, dept_id from s_emp; 按照列表进行查询in 表示在....里 not in 表示不在...里1234567891011121314151617-- 查询员工表中部门编号为41或42的员工名称、薪水以及部门编号信息select first_name, salary, dept_id from s_empwhere dept_id = 41 or dept_id = 42;select first_name, salary, dept_id from s_empwhere dept_id &gt;= 41 and dept_id &lt;= 42;select first_name, salary, dept_id from s_empwhere dept_id between 41 and 42;select first_name, salary, dept_id from s_empwhere dept_id in(41, 42);-- 不推荐使用select first_name, salary, dept_id from s_empwhere dept_id not in(43, 34, 44, 31, 32, 35, 50, 45, 33, 10); -- 查询员工表中部门编号不为41和42的员工名称，薪水以及部门编号信息select first_name, salary, dept_id from s_empwhere dept_id not in(41, 42); 模糊查询like ... 表示按照指定的条件进行模糊查询 _ 表示可以出现任意一个字符 % 表示可以出现任意多个字符1234567891011121314151617181920212223242526272829303132333435363738394041424344454647-- 查询员工表中名字使用字母b开头的员工名字以及员工薪水-- 由于大小写问题查询不到任何数据select first_name, salary from s_empwhere first_name like 'b%';-- 查询到数据select first_name, salary from s_empwhere first_name like 'B%';-- 查询员工表中名字中带'德'的员工名字以及薪水select first_name, salary from s_empwhere first_name like '%德%';-- 查询员工表中名字以'德'结尾的员工名字以及薪水select first_name, salary from s_empwhere first_name like '%德';-- 查询员工表中名字带'拉'的员工名字以及薪水select first_name, salary from s_empwhere first_name like '%拉%';-- 查询员工表中名字以'拉'开头的员工名字以及薪水select first_name, salary from s_empwhere first_name like '拉%';-- 查询员工表中名字以'拉'结尾的员工名字以及薪水select first_name, salary from s_empwhere first_name like '%拉';-- 查询员工表中名字以'拉'结尾前面只有一个字符的员工名字以及薪水select first_name, salary from s_empwhere first_name like '_拉';-- 查询员工表中名字以'拉'开头后面只有一个字符的员工名字以及薪水select first_name, salary from s_empwhere first_name like '拉_';-- 查询员工表中名字以'_'开头的员工名字以及薪水-- 查询到员工表中的所有数据，不符合需求select first_name, salary from s_emp where first_name like '_%';-- 插入一个员工信息到员工表中insert into s_emp (id, first_name, salary) values(26, '_泰江', 20);-- 使用单引号进行转义 Error:无效的字符select first_name, salary from s_emp where first_name like ''_%'; -- 需要指定转义字符select first_name, salary from s_emp where first_name like '\\_%' escape '\\'; -- 指定'#'转义字符select first_name, salary from s_emp where first_name like '#_%' escape '#'; 练习讲解：desc student 表示查看学生表的结构 名称 空值 类型 ----------- -------- ------------- STUDENTNO NOT NULL VARCHAR2(50) -- 学生的学号 LOGINPWD NOT NULL VARCHAR2(20) -- 登录密码 STUDENTNAME NOT NULL VARCHAR2(50) -- 学生的姓名 SEX NOT NULL CHAR(3) -- 学生的性别 GRADEID NOT NULL NUMBER(2) -- 年级的编号 PHONE NOT NULL VARCHAR2(255) -- 电话号码 ADDRESS VARCHAR2(255) -- 通讯地址 BORNDATE DATE -- 出生日期 EMAIL VARCHAR2(50) -- 邮箱地址 desc grade 表示查看年级表的结构 名称 空值 类型 --------- -------- ------------ GRADEID NOT NULL NUMBER(2) -- 年级编号 GRADENAME NOT NULL VARCHAR2(20) -- 年级名称 desc subject 表示查看课程表的结构 名称 空值 类型 ----------- -------- ------------ SUBJECTID NOT NULL NUMBER(2) -- 课程编号 SUBJECTNAME NOT NULL VARCHAR2(50) -- 课程名称 CLASSHOUR NOT NULL NUMBER(2) -- 课程课时 GRADEID NOT NULL NUMBER(2) -- 年级编号 desc result 表示查看成绩表的结构 名称 空值 类型 ------------- -------- ------------ ID NOT NULL NUMBER(4) -- 成绩的编号 STUDENTNO NOT NULL VARCHAR2(50) -- 学生的学号 SUBJECTID NOT NULL NUMBER(2) -- 课程的编号 STUDENTRESULT NUMBER(4) -- 学生的成绩 EXAMDATE NOT NULL DATE -- 考试时间12345678910111213141516-- 查询“山东”的学生姓名、电话、住址select studentname, phone, address from studentwhere address like '山东%';-- 查询名称中含有“p”字母的科目信息select subjectname from subjectwhere subjectname like '%p%';-- 查询电话中以“1387”开头的学生信息select studentname, phone from studentwhere phone like '1387%';-- 查询姓姜的，单名的学生信息select studentname from studentwhere studentname like '姜_';-- 查询学号为S1101004的指定1，2，3科目考试成绩select studentno, subjectid, studentresult from resultwhere studentno = 'S1101004' and subjectid in(1, 2, 3); 作业：--查看表结构s_dept表，并且从s_dept表中，查询ID、name字段对应的内容 --查看员工表中所有员工的每个月涨薪500元后的年薪 --当前时间使用sysdate获取,计算一下每位员工在公司的天数，要求显示字段： id、first_name、入职时间、在公司的天数，其中在公司的天数用days显示(起别名) --查询员工信息：员工编号、员工姓名以及员工的领导编号，没领导就设置为-1 --查询员工表中部门在31、32、33的员工编号、员工姓名以及部门编号信息","categories":[{"name":"oracle","slug":"oracle","permalink":"https://chensnape.github.io/categories/oracle/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"https://chensnape.github.io/tags/oracle/"},{"name":"查询基础","slug":"查询基础","permalink":"https://chensnape.github.io/tags/查询基础/"}],"keywords":[{"name":"oracle","slug":"oracle","permalink":"https://chensnape.github.io/categories/oracle/"}]},{"title":"1数据库、DDL、DML","slug":"1数据库、DDL、DML","date":"2019-09-16T08:57:56.000Z","updated":"2019-09-16T03:12:44.195Z","comments":true,"path":"2019/09/16/1数据库、DDL、DML/","link":"","permalink":"https://chensnape.github.io/2019/09/16/1数据库、DDL、DML/","excerpt":"","text":"数据库、DDL、DML2019/8/27 9:20:47 数据库的概述主流的数据库目前主流的数据库有:Oracle、Mysql、SQL、Server、DB2、...Oracle环境的搭建(会)Oracle的安装和卸载(1)下载方式: www.oracle.com (2)安装方式: 对于精简版来说，一路点击下一步进行安装即可，密码设置为:123456 切记安装路径中不能有中文路径 计算机右键 =&gt;管理 =&gt; 服务 (3)卸载方式: 控制面板 =&gt; 程序功能 =&gt; 找到oracle，点击右键选择卸载 =&gt; 下一步切记删除oracle的安装目录！Oracle的访问方式(1)当数据库没有安装在本地主机时，需要使用telnet IP地址 的方式登录远程服务器 a.使用命令行工具在dos窗口中输入sqlplus后输入数据库账号和密码即可； b.使用图形化工具sql developer输入账号和密码进行登录；表空间和账户的创建由于system账户是Oracle的管理员账户，若使用该账户操作数据库时可能会造成无法恢复的误操作，因此需要开通新的账户和 表空间，所谓表空间就是该账户在磁盘上可以访问的磁盘空间，具体方式如下：12345678910111213141516171819create tablespace practice -- 表示创建名字为practice的表空间datafile 'D:/practice.dbf' -- 表示关联到D:/practice.dbf的文件size 10M; -- 表示空间的大小为10兆 drop tablespace practice -- 表示删除名字为practice表空间including contents and datafiles; -- 表示将内容和文件一并删除create user xiaomage -- 表示创建名字为xiaomage的账户identified by 123456 -- 表示设置该账户的密码为123456default tablespace practice; -- 表示设置该账户的默认表空间为practicedrop user xiaomage; -- 表示删除名字为xiaomage的账户grant create view to xiaomage; -- 表示授予xiaomage创建视图的权限grant connect, resource to xiaomage; -- 表示授予连接、建表等权限 revoke create view from xiaomage; -- 撤销创建视图的权限revoke connect, resource from xiaomage; -- 撤销连接、建表等权限 常用的数据类型(重点)Java语言中的数据类型有：byte、short、int、long、float、double、boolean、char类型、String类型、... Oracle数据中的数据类型有： number(n) - 表示具有n位数字的整数数值，无数字相当于38位, 如：number(2)等 number(n,m) - 表示该数值具有n位数字，其中小数点后面有m位数字， 如：number(3,2)等 char(n) - 表示描述长度为n的定长字符串，若没有存满则使用空格补齐， 如：char(3)等 varchar2(n) - 表示描述长度为n的变长字符串，若没有存满则自动缩小， 如：varchar2(20)等 date - 表示描述年月日时分秒的日期数据。SQL结构化查询语言(重中之重)基本分类(记住)(1)DDL数据定义语句(Data Definition Language) - 主要用于实现对表格的创建、修改以及删除操作。 (2)DML数据操作语句(Data Manipulation Language) - 主要用于实现对表格内中数据的插入、修改(更新)以及删除操作。 (3)Select查询语句 - 主要用于实现对表格内数据的查询操作。 (4)TCL事务控制语句(Transaction Control Language) - 主要用于实现对数据更改的提交和回滚(撤销)等操作。DDL数据定义语句(1)创建表格的语法格式 create table 表名( 字段名称1 字段类型, 字段名称2 字段类型, ... ); 如： create table person( -- 表示创建名字为person的表格 name varchar2(30), -- 表示姓名字段 age number(3), -- 表示年龄字段 sex char(3) -- 表示性别字段 ); 练习讲解：-- 创建供应商表 create table provider( sNo char(2), sName varchar2(8), city varchar2(20) ); -- 创建产品表 create table product( pNo char(2), pName varchar2(8), kind number(2) ); -- 创建供应情况表 create table supply( sNO char(2), pNo char(2), qty number(2) ); (2)修改表格的语法格式(会用即可) alter table 表名 drop column 列名; 如： -- 删除person表中名字为sex的列 alter table person drop column sex; alter table 表名 add 列名 类型; 如： -- 向person表中添加名字为gender的列 alter table person add gender char(3); alter table 表名 rename to 新的表名; 如： -- 实现将person表的名字更改为people alter table person rename to people; alter table 表名 rename column 列名 to 新的列名 如： -- 实现将people表中名字为gender的列名更改为sex alter table people rename column gender to sex; 练习讲解： -- 为了便于后期对表格的扩展，可以在创建表格时提供保留字段 create table commodity ( pid varchar2(8), title varchar2(20), price number(8,2), gid number(2), description clob, count number(6), baoliu1 varchar2(20), baoliu2 varchar2(20), baoliu3 varchar2(20) ); (3)删除表格的语法格式 drop table 表名; 如： -- 实现名字为people表格的删除 drop table people;DML数据操作语句(1)插入数据的语法格式 insert into 表名 [(列名1, 列名2, ...)] values(数值1, 数值2, ...); 如： -- 向person表中插入数据 &apos;韩策&apos; insert into person (name, age, sex) values(&apos;韩策&apos;, 18, &apos;男&apos;); -- 向person表中插入数据 &apos;苍老师&apos; -- 以后的开发中若插入的是所有字段的数据通常都省略，而且推荐该方式 insert into person values(&apos;苍老师&apos;, 20, &apos;女&apos;); -- 向person表中插入数据 &apos;范栓鹏&apos; &apos;男&apos; -- 当插入部分字段的数据时列名不允许省略 insert into person (name, sex) values(&apos;范栓鹏&apos;, &apos;男&apos;); (2)更新/修改数据的语法格式 update 表名 set 列名 = 值 [where 条件]; 如： -- 实现将person表中所有人的年龄修改为18 update person set age = 18; -- 实现将person表中名字为&apos;范栓鹏&apos;的年龄修改为16 update person set age = 16 where name = &apos;范栓鹏&apos;; (3)删除数据的语法格式 delete [from] 表名 [where 条件]; 如： -- 实现将person表中名字为&apos;苍老师&apos;的记录删除 delete from person where name = &apos;苍老师&apos;; -- 实现将person表中所有数据删除 delete from person;作业：1.重点掌握常用的数据类型、表格的创建和删除、数据的插入、更新以及删除。 2.创建女孩表，字段有：姓名、年龄、电话号码、是否有男朋友 向该表中插入&apos;貂蝉&apos;、&apos;西施&apos;、&apos;王昭君&apos;的个人信息 更新该表中&apos;貂蝉&apos;的电话号码为119 更新该表中所有人的年龄为18 删除名字为&apos;王昭君&apos;的记录 删除所有记录 删除女孩表","categories":[{"name":"oracle","slug":"oracle","permalink":"https://chensnape.github.io/categories/oracle/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"https://chensnape.github.io/tags/oracle/"},{"name":"DDL、DML","slug":"DDL、DML","permalink":"https://chensnape.github.io/tags/DDL、DML/"}],"keywords":[{"name":"oracle","slug":"oracle","permalink":"https://chensnape.github.io/categories/oracle/"}]},{"title":"索引_javase","slug":"索引-javase","date":"2019-09-14T21:03:23.000Z","updated":"2019-09-16T03:27:27.979Z","comments":true,"path":"2019/09/15/索引-javase/","link":"","permalink":"https://chensnape.github.io/2019/09/15/索引-javase/","excerpt":"","text":"javase_01计算机的体系结构、常用快捷键、常用的dos命令javase_02变量和注释、数据类型javase_03字符类型、运算符javase_04分支结构、循环结构 if、switch-case、forjavase_05循环结构、一维数组 while、breakjavase_06二维数组、面向对象编程的概念javase_07成员方法、构造方法和方法重载 Overridejavase_08this关键字、方法的传参过程和递归调用、封装javase_09static关键字、单例设计模式、继承javase_10访问控制、final关键字、多态、抽象类javase_11接口、匿名内部类、Object类* equals、hashCode、toStringjavase_12包装类和数学处理类、String类、常量池javase_13String类、StringBuilder类和Stringbuffer类* 日期相关的类、集合框架、Collection集合* SimpleDateFormat、Calenderjavase_14List集合javase_15泛型机制、Queue集合、Set集合、Map集合 itertor迭代器、for eachjavase_16异常机制、File类、I/O流、finally、throw FileOutputStream类、FileInputStream类javase_17IO流、线程、PrintStream类、BufferedReader类 ObjectOutputStream类、ObjectInputStream类 Thread、Runnablejavase_18线程的常用方法、线程的同步机制、网络编程的常识、基于tcp协议的编程模型javase_19基于tcp协议的编程模型、常用的设计原则、常用的设计模式 ServerSocketjavase_20常用的设计模式、常用的查找算法、常用的排序算法、在线考试系统javase_21在线考试系统","categories":[{"name":"索引","slug":"索引","permalink":"https://chensnape.github.io/categories/索引/"}],"tags":[{"name":"索引","slug":"索引","permalink":"https://chensnape.github.io/tags/索引/"}],"keywords":[{"name":"索引","slug":"索引","permalink":"https://chensnape.github.io/categories/索引/"}]},{"title":"21基于tcp的在线考试系统","slug":"21基于tcp的在线考试系统","date":"2019-09-14T21:02:23.000Z","updated":"2019-09-16T03:24:57.994Z","comments":true,"path":"2019/09/15/21基于tcp的在线考试系统/","link":"","permalink":"https://chensnape.github.io/2019/09/15/21基于tcp的在线考试系统/","excerpt":"","text":"在线考试系统2019/8/25 9:43:05 项目开发的目标(1)综合应用JavaSE阶段的所有内容。 (2)了解项目开发的基本架构。项目开发的流程需求分析文档 =&gt; 概要设计文档 =&gt; 详细设计文档 =&gt; 编码和测试 =&gt; 安装和调试 =&gt; 维护和升级项目的功能兄弟连在线考试系统的功能模块主要有： (1)学员系统 a.账户管理：登录、退出、修改密码、... b.考试管理：开始考试、提交试卷、显示成绩、... (2)管理员系统 a.学员管理：增加学员、删除学员、修改学员、查找学员、显示学员、... b.考题管理：增加考题、删除考题、修改考题、查找考题、显示考题、...项目的架构兄弟连在线考试系统采用C(Client)/S(Server)架构进行设计，主要分为以下三层： 客户端 - 主要用于提供字符界面让客户进行业务的选择； 服务器 - 主要用于根据客户的业务选择实现真正的业务处理； 数据库 - 主要用于进行数据内容的读写；项目的实现客户端和服务器之间采用基于TCP协议的编程模型进行通信。 其中客户端的输出流连接服务器的输入流； 其中客户端的输入流连接服务器的输出流； 客户端和服务器之间采用对象流进行通信，其中对象的类型用于代表具体的业务。 UserMessage tum = new UserMessage(&quot;check&quot;, -- 其中check就代表校验操作 new User(&quot;admin&quot;, &quot;123456a&quot;)); 当服务器处理完毕之后可以通过对象的类型向客户端发送处理的结果。 当校验成功时，可以将对象的类型改为&quot;success&quot;再发送给客户端 当校验失败时，可以将对象的类型改为&quot;fail&quot;再发送给客户端项目的编码流程(1)实现客户端的字符界面提供给客户选择，将客户端选择的业务发送给服务器； (2)服务器接收到选择的业务类型后通过访问数据库的方式实现业务功能的处理； (3)实现客户端接收服务器的处理结果并给出对应的提示；","categories":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/tags/java/"},{"name":"基于tcp的在线考试系统","slug":"基于tcp的在线考试系统","permalink":"https://chensnape.github.io/tags/基于tcp的在线考试系统/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}]},{"title":"20常用设计模式、基础算法","slug":"20常用设计模式、基础算法","date":"2019-09-14T21:01:53.000Z","updated":"2019-09-16T03:24:47.290Z","comments":true,"path":"2019/09/15/20常用设计模式、基础算法/","link":"","permalink":"https://chensnape.github.io/2019/09/15/20常用设计模式、基础算法/","excerpt":"","text":"常用的设计模式、常用的查找算法、常用的排序算法、在线考试系统2019/8/23 9:43:05 常用的设计模式(重点)(1)基本概念 设计模式就是一种反复使用、代码设计经验的总结，是一种用于固定场合的固定套路 (2)常用的设计模式 单例设计模式、模板设计模式、工厂方法模式、抽象工厂模式...常用的查找算法(重点)线性(顺序)查找算法二分(折半)查找算法常用的排序算法冒泡排序算法(重中之重)练习自定义PacketSender类实现Sender接口并重写send方法； 在SendFactory类中自定义静态方法负责创建PacketSender类型的对象并返回； 在SendFactoryTest类中进行测试；作业重点掌握常用设计模式和常用算法 学习选修内容switch-case结构以及学生信息管理系统 预习兄弟连在线考试系统的文档","categories":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/tags/java/"},{"name":"常用设计模式、基础算法","slug":"常用设计模式、基础算法","permalink":"https://chensnape.github.io/tags/常用设计模式、基础算法/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}]},{"title":"19tcp编程模型、常用设计原则、模式","slug":"19tcp编程模型、常用设计原则、模式","date":"2019-09-14T21:01:25.000Z","updated":"2019-09-16T03:24:35.430Z","comments":true,"path":"2019/09/15/19tcp编程模型、常用设计原则、模式/","link":"","permalink":"https://chensnape.github.io/2019/09/15/19tcp编程模型、常用设计原则、模式/","excerpt":"","text":"基于tcp协议的编程模型、常用的设计原则、常用的设计模式2019/8/22 8:51:30 基于tcp协议的编程模型编程模型服务器： (1)创建ServerSocket类型的对象并提供端口号 (2)等待客户端连接请求，调用accept方法 (3)使用输入输出流进行通信 (4)关闭Socket并释放有关资源 客户端： (1)创建Socket类型的对象并提供服务器的通信地址和端口号； (2)使用输入输出流进行通信； (3)关闭Socket并释放有关资源常用的设计原则(记住)软件开发的流程需求分析文档 =&gt; 概要设计文档 =&gt; 详细设计文档 =&gt; 编码和测试 =&gt; 安装和调试 =&gt; 维护和升级常用的设计原则开闭原则 - 对扩展开放，对修改关闭123456789101112131415161718192021222324252627 public class Person&#123; private String name; public Person()&#123; &#125; ... &#125; public class SubPerson extends Person&#123; private int age; ... &#125;``` 里氏代换原则 - 任何基类可以出现的地方，子类一定可以出现 - 建议多使用多态,屏蔽不同子类的差异性实现通用的编程 - 子类 is a 父类 ``` java public static void draw(Shap s)&#123; s.show(); &#125; draw(new Circle(11,2,3)); draw(new Rect(1,2,3,4)); 依赖倒转原则 - 在以后的开发中尽量多依赖于抽象类和接口类而不是具体实现类 - 抽象类和接口对子类具有强制性和规范性 123456789public abstract class Account&#123; public abstract double getLixi();&#125;public class FixedAccount extends Account&#123; @Override public double getLixi()&#123;...&#125;&#125; 接口隔离原则 - 尽量多依赖于小接口而不是大接口，避免接口的污染12345678public interface RunAnimal&#123; public abstract void run();&#125;public interface FlyAnimal&#123; public abstract void fly();&#125;public class Dog implements RunAnimal&#123;&#125; 迪米特法则(最少知道原则) - 一个实体尽量少与其它实体之间发生互相作用 - 高内聚，低耦合 - 所谓高内聚就是指一个实体应该有的所有功能都尽量聚焦于该实体的内部 - 所谓低耦合就是指一个实体应该尽量减少与其它实体之间的关联度 合成复用原则 - 尽量多使用合成/聚合的方式，而不是继承的方式 public class A{ public void show(){...} } public class B extends A { //继承的方式，不推荐 public void test(){ //希望调用show方法 show(); } } public class B { //合成复用的方式，推荐 private A a; public B(A a){ this.a=a; } public void test(){ //希望调用show方法 show(); } } 常用的设计模式(1)基本概念 设计模式是一套被反复使用、代码设计经验的总结，用于固定场合中的固定套路。 (2)常用设计模式(重点) 单例设计模式、模板设计模式、工厂方法模式作业(1)重点掌握基于tcp协议编程模型的代码。 (2)使用基于tcp协议的编程模型实现将UserMessage类型对象由客户端发送给服务器； 服务器接收到对象后判断用户对象信息是否为&quot;admin&quot;和&quot;123456&quot;，若是则将 UserMessage对象中的类型改为&quot;success&quot;，否则将类型改为&quot;fail&quot;并回发给客户端 客户端接收到服务器发来的对象后判断并给出提示。 其中UserMessage类的特征有：类型(字符串类型) 和 用户对象(User类型)。 其中User类的特征有：用户名、密码(字符串类型)。 如： UserMessage tum = new UserMessage(&quot;check&quot;, new User(&quot;admin&quot;, &quot;123456&quot;)); (3)预习在线考试系统的文档。","categories":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/tags/java/"},{"name":"tcp编程模型、常用设计原则、模式","slug":"tcp编程模型、常用设计原则、模式","permalink":"https://chensnape.github.io/tags/tcp编程模型、常用设计原则、模式/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}]},{"title":"18线程、网络编程","slug":"18线程、网络编程","date":"2019-09-14T21:00:46.000Z","updated":"2019-09-16T03:24:19.227Z","comments":true,"path":"2019/09/15/18线程、网络编程/","link":"","permalink":"https://chensnape.github.io/2019/09/15/18线程、网络编程/","excerpt":"","text":"线程的常用方法、线程的同步机制、网络编程的常识、基于tcp协议的编程模型2019/8/21 14:03:36 线程的常用方法(重点)线程的同步机制(重点)基本概念当多个线程同时访问同一种共享资源时，可能会造成数据的覆盖等不一致性问题，此时就需要对多个线程 之间进行通信和协调，该机制就叫做线程的同步机制解决方案由程序结果可知：当两个线程同时对同一个账户取款时，导致最终的账户余额不合理 引发原因：第一个线程还没有取款结束第二个线程就已经开始取款 解决方案：让第一个线程取款结束后再让第二个线程开始取款 将线程的并发操作改为串行操作即可 注意事项：为了提高代码的并发效率，应该尽量减少锁定的范围实现方式在Java语言中提供了一种内置的锁机制来保证代码执行的原子性，需要使用synchronized关键字加以修饰死锁的概念123456789101112131415161718//线程一执行的代码：public void run()&#123; synchronized(a)&#123; synchronized(b)&#123; //持有对象锁a等待对象锁b ... &#125; &#125;&#125;//线程二执行的代码：public void run()&#123; synchronized(b)&#123; synchronized(a)&#123; //持有对象锁b等待对象锁a ... &#125; &#125;&#125; 注意： 在以后的开发中尽量不要使用同步代码块的嵌套结构来避免死锁的发生网络编程的常识(理解)目前主流的网络通讯软件有：QQ、微信、微博、陌陌、阿里巴巴、钉钉、飞信、...七层网络模型为了数据传输的可靠性和安全性，ISO(国际标准委员会组织)将数据的传递从逻辑上划分为七层 应用层、表示层、会话层、传输层、网络层、数据连接层、物理层 当发送数据时，需要对发送的数据按照上述七层模型进行层层加包再发送出去； 当接受数据时，需要对接受的数据按照上述 七层相反的次序进行层层拆包贼显示IP地址192.168.1.1 - 是绝大多数路由器的登陆地址，进行账户密码的设置以及MAC地址过滤 IP地址就是互联网的唯一地址标识，也就是通过IP地址可以定位到具体某一台设备 IP地址本质上是由32位二进制组成的整数，叫做IPv4，当然也有128位二进制组成的整数，叫做IPv6目前主流的还是IPv4。 日常生活中采用点分十进制表示法来进行IP地址的描述，也就是将每个字节的二进制转换为一个十进制整数，不同的 十进制整数之间使用小数点隔开端口号根据IP地址可以定位到具体设备，而根据端口号可以定位到设备中的进程 网络编程需要提供：IP地址 和 端口号 端口号本质上是由16位二进制组成的整数，表示的范围是：0~65535，其中0~1024之间的端口号通常被系统占用 因此以后的开发从1025开始使用。作业(1)重点掌握线程的常用方法和线程同步的代码。 (2)复习所有内容准备后天的阶段考试。","categories":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/tags/java/"},{"name":"线程、网络编程","slug":"线程、网络编程","permalink":"https://chensnape.github.io/tags/线程、网络编程/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}]},{"title":"17IO流、线程","slug":"17IO流、线程","date":"2019-09-14T21:00:21.000Z","updated":"2019-09-16T03:24:05.922Z","comments":true,"path":"2019/09/15/17IO流、线程/","link":"","permalink":"https://chensnape.github.io/2019/09/15/17IO流、线程/","excerpt":"","text":"IO流、线程2019/8/20 9:30:30 IO流PrintStream类(重点)(1)基本概念 java.io.PrintStream类主要用于方便地打印各种数据内容并且自动刷新 (2)常用方法BufferedReader类(重点)(1)基本概念 java.io.BufferedReader类主要用于读取单个字符、字符数组以及一行字符串 (2)常用方法ObjectOutputStream类(重点)(1)基本概念 java.io.ObjectOutputStream类只要用于将Java语言中的对象整体写入到输出流中 只能将支持 java.io.Serializable 接口的对象写入流中，也就是说被写入对象的数据类型必须实现该接口 类通过实现 java.io.Seria;izable 接口以启用其序列化功能 所谓序列化主要指将一个对象需要保持的所有相关信息有效组织成字节序列化的转换过程 (2)常用方法ObjectInputStream类(重点)(1)基本概念 java.io.ObjectInputStream类主要用于从输入流中将一个对象整体读取出来 (2)常用方法 经验分享： 当需要向文件中写入多个对象时，可以先将多个对象放入一个集合中，然后将集合这个整体看作 一个对象调用一次weiteObject方法整体写入文件，此时只需要调用一次readObject方法就 可以将整个集合读取出来线程(重点)基本概念程序 - 数据结构 + 算法，主要指存放在硬盘上的可执行文件 进程 - 主要指运行在内存中的可执行文件 目前主流的操作系统都支持多进程，是为了让操作系统同时执行多个任务，但进程是重量级的，新建进程 对系统的资源消耗比较大，因此进程的数量比较局限 线程是进程内部的程序流，也就是说操作系统中支持多进程，而每个进程的内部又可以支持多个线程，并且 线程是轻量级的，新建线程会共享所在进程的系统资源，因此主流的开发都采用多线程 多线程技术是采用时间片轮转法来保证线程的并发执行，所谓并发就是指宏观并行微观串行的机制线程的创建(重中之重)(1)线程的创建方式 java.lang.Thread类主要用于描述线程，Java虚拟机允许应用程序执行多个线程 而线程的创建和启动方式如下： a.自定义类继承Thread类并重写run方法，然后创建该类的对象调用start方法； b.自定义类实现Runnable接口并重写run方法，然后创建该类的对象作为实参来构造Thread类 的对象，最后使用Thread类的对象调用start方法； (2)相关方法的解析 Thread() - 使用无参方式构造对象 Thread(String name) - 根据参数指定的名称来构造对象 Thread(Runnable target) - 根据参数指定的接口引用来构造对象 Thread(Runnable target, String name) - 根据参数指定的接口引用和名称构造对象 void run() - 若线程对象是采用Runnable对象构造的，调用run方法时最终调用 Runnable接口引用所指向的run方法，否则调用该方法啥也不做。 void start() - 用于启动线程，Java虚拟机会自动调用该线程的run方法。 (3)原理分析 a.执行main方法的线程叫做主线程，执行run方法的线程叫做子线程； b.main方法是程序的入口，对于start方法调用之前的代码来说由主线程执行一次 当start方法调用成功后线程的个数由1个变成了2个，新创建的线程去执行run方法的代码 主线程继续向下执行，两个线程各自独立运行互不影响； c.当run方法执行完毕后则子线程结束，当main方法执行完毕后主线程结束，两个线程 的先后执行次序没有明确的规定，由系统的调度算法决定； (4)两种方式的比较 a.使用继承Thread类的方式代码比较简单，但Java语言中支持单继承，若该类继承了 Thread类就无法继承其它类。 b.使用实现Runnable接口的方式代码比较复杂，但不影响该类继承其它类以及实现其 它接口，在以后的开发中推荐该方式。线程的编号和名称(会用即可)作业(1)重点掌握线程创建的两种方式和对象流的使用。 (2)不断地提示用户输入要发送的内容，若发送的内容是&quot;bye&quot;则聊天结束，否则将用户输入的内容写入到文件 c:/a.txt中。要求使用BufferedReader类来读取键盘的输入 System.in代表键盘输入要求使用 PrintStream类负责将数据写入文件 (3)编程创建两个线程，线程一负责打印1 ~ 100之间的所有奇数；其中线程二负责打印1 ~ 100之间的所有 偶数；在main方法启动上述两个线程同时执行,主线程等待两个线程终止； (4)编程实现Account类的封装，特征有：账户余额； 编程实现AccountTest类，在main方法中创建对象并传入1000元，最后打印余额","categories":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/tags/java/"},{"name":"IO流、线程","slug":"IO流、线程","permalink":"https://chensnape.github.io/tags/IO流、线程/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}]},{"title":"16异常机制、File类、IO流","slug":"16异常机制、File类、IO流","date":"2019-09-14T20:59:43.000Z","updated":"2019-09-16T03:23:53.411Z","comments":true,"path":"2019/09/15/16异常机制、File类、IO流/","link":"","permalink":"https://chensnape.github.io/2019/09/15/16异常机制、File类、IO流/","excerpt":"","text":"异常机制、File类、I/O流2019/8/19 9:30:15 异常机制基本概念异常就是&quot;不正常&quot;的含义，Java语言中体现为程序在运行阶段的错误 java.lang.Throwable类是所有错误(Error类)或异常(Exception类)的超类 其中Error类主要用于描述比较严重无法通过编码解决的错误，如：JVM挂了等 其中Exception类主要用于描述比较轻微可以通过编码解决的错误，如：0作为除数等异常分类java.lang.Exception类是所有异常的超类，具体分类如下： RuntimeException - 运行时异常，也叫做非检测性异常 IOException和其它异常 - 其它异常，也叫做检测性异常 - 所谓检测性异常主要指在编译阶段能够被编译器检测出来的异常 RuntimeException类的主要子类 ..... 注意: 当程序执行过程中发生异常却又没有手动处理时，该异常由Java虚拟机采用默认方式处理 而默认处理方式就是打印异常名称、异常原因、异常发生的位置并终止程序避免异常在以后的开发中尽量多使用if条件判断避免异常的发生异常的捕获(1)语法格式 try{ 编写可能发生异常的语句块； } catch(异常类型 变量名){ 编写针对该类异常进行处理的语句块； } ... finally{ 编写无论是否发生异常都应该执行的语句块； } (2)注意事项 a.当需要编写多个catch分支时，切记小类型异常放在大类型异常的前面； 懒人的写法： catch(Exception e) {...} b.finally中通常用于编写善后处理的代码，如：关闭已经打开的文件等 (3)执行流程 try{ a; b; - 可能发生异常的语句； c; }catch(){ d; }finally{ e; } 当程序执行过程中没有发生异常时的执行流程：a,b,c,e 当程序执行过程中发生异常时的执行流程：a,b,d,e异常的抛出(1)基本概念 在程序执行中发生了异常却又没法直接处理时，就可以直接将异常转移给该方法的调用者进行处理 该过程就叫做异常的抛出 (2)语法格式 访问权限 返回值类型 方法名称(形参列表) theows 异常类型1，异常类型2...{} 如： public void show() throws IOException{...} (3)方法重写的原则 a.要求方法名相同、参数列表相同以及返回值类型相同，从jdk1.5开始允许返回子类 b.要求访问权限不能变小，可以相同或者变大； c.要求不能抛出更大的异常(异常机制)； 注意： 子类重写的方法可以抛出和父类一样的异常、可以抛出更小的异常以及不抛出异常 但不可以抛出平级不一样或者更大的异常。自定义异常(1)基本概念 虽然Java官方提供大量的异常类，但没有提供对年龄不合理的异常，为了在程序中表达这种针对性的错误 信息，就需要程序员自定义异常 (2)实现流程 a.自定义xxxException继承自Exception或者其子类； b.提供两个版本的构造方法：一个是无参构造方法 和一个字符串作为参数的构造方法 (3)异常抛出 throw new 异常类型();File类(会用即可)基本概念java.io.File类主要用于描述文件和目录的路径信息，可以获取文件和目录的属性 但不可以修改文件中的内容。常用方法I/O流基本概念I/O就是Input/Output的简写，也就是输入/输出的含义 I/O流就是指读写数据时像流水一样不间断，因此得名为“流”基本分类根据数据读写的单位不同分为：字节流 和 字符流 其中字节流主要指以字节为单位进行读写的流，可以读写任意类型的文件 其中字符流主要指以字符(2个字节)为单位进行读写的流，只能读写文本文件 根据数据流动的方向不同分为：输入流 和 输出流(站在程序的角度) 其中输入流主要指将数据从文件输入到程序中，也就是读取文件中的内容 其中输出流主要指将数据从程序输出到文件中，也就是写入到文件中FileOutputStream类(重中之重)(1)基本概念 java.io.FileOutputStream类主要用于将图像数据之类的原始字节流写入到输出流中 (2)常用方法FileInputStream类(重中之重)(1)基本概念 java.io.FileInputStream类主要用于从输入流中读取图像数据之类的原始字节流。 (2)常用方法作业(1)重点掌握异常机制的总结图和文件的拷贝方式。 (2)编写选修内容中的学生信息管理系统，为JavaSE阶段的项目做铺垫。","categories":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/tags/java/"},{"name":"异常机制、File类、IO流","slug":"异常机制、File类、IO流","permalink":"https://chensnape.github.io/tags/异常机制、File类、IO流/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}]},{"title":"15泛型机制、Queue、Set、Map集合","slug":"15泛型机制、Queue、Set、Map集合","date":"2019-09-14T20:59:11.000Z","updated":"2019-09-16T03:23:43.367Z","comments":true,"path":"2019/09/15/15泛型机制、Queue、Set、Map集合/","link":"","permalink":"https://chensnape.github.io/2019/09/15/15泛型机制、Queue、Set、Map集合/","excerpt":"","text":"泛型机制、Queue集合、Set集合、Map集合2019/8/17 8:59:17 泛型机制(重点)基本概念为了避免类型转换异常的发生，从jdk1.5开始提出泛型机制，也就是在集合名称的右侧使用&lt;数据类型&gt;的方式 明确要求该集合中可以存放的元素类型，若存放其它类型的数据则编译报错，如： List&lt;String&gt; lt1 = new LinkedList&lt;String&gt;(); 泛型的本质泛型的本质就是参数化类型，也就是说让数据类型作为参数进行传递，其中E相当于形式参数 在集合中负责占位，而创建集合时&lt;&gt;中的数据类型相当于实际参数用于给形式参数进行初始化于是 合中所有E都被替换为实际参数对应的类型。 由于实际参数支持非常广泛的类型，因此得名为“泛型”1234567891011//其中int i叫做形式参数 负责占位 其中E叫做形式参数，负责占位//int i=5; E =String;//int i=8; E =Student;public void show()&#123; public interface List&lt;E&gt;&#123; ... ...&#125; &#125;//其中5叫做实际参数，用于给形参初始化 其中String叫做实际参数，给形参赋值show(5); List&lt;String&gt; lt1 = ...//其中8叫做实际参数，用于给形参初始化 其中Student叫做实际参数，给形参赋值show(8); List&lt;Student&gt; lt2 = ... Queue集合基本概念java.util.Queue集合是Collection集合的子集合，与List集合平级 该集合主要用于描述具有先进先出特性的数据结构，叫做队列 (First in First out FIFO) 该集合的主要实现类是LinkedList类，选择该类是因为队列需要大量的增删操作常用方法Set集合基本概念java.util.Set集合是Collection集合的子集合，与List集合是平级关系 该集合中不允许有重复的元素，并且元素之间没有先后次序 该集合的作用实现类有：HashSet类 和 TreeSet类 其中HashSet类的底层是采用哈希表进行数据管理的 其中TreeSet类的底层是采用二叉树进行数据管理的常用方法参考Collection集合中的常用方法即可 Iterator&lt;E&gt; itertor - 用于获取当前集合中的迭代器，可以遍历集合中所有元素增强版的for循环(for each结构)(1)语法格式 for(元素类型 变量名：数组/集合名称){ 循环体； } (2)执行流程 不断地从数组/集合中取出一个元素赋值给变量名后执行循环体，直到处理完所有元素Map集合基本概念java.util.Map&lt;K,V&gt;集合中存取元素的基本单位是：单对元素，具体类型参数如下： K - 此映射所维护的键(Key)的类型 V - 映射值(Value)的类型 该集合中不能包含重复的键；每个键最多只能映射到一个值。 该集合的主要实现类有：HashMap类 和 TreeMap类。常用方法作业(1)复习和总结集合所有内容，重点掌握Queue、Stack集合及拼接实现和字符串统计。 (2)准备一个HashSet集合，实现生成10个1~20之间不重复的随机数放入集合并打印。 (3)声明一个List集合放入11、22、33、44、55，分别使用4种方式遍历。","categories":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/tags/java/"},{"name":"泛型机制、Queue、Set、Map集合","slug":"泛型机制、Queue、Set、Map集合","permalink":"https://chensnape.github.io/tags/泛型机制、Queue、Set、Map集合/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}]},{"title":"14List集合","slug":"14List集合","date":"2019-09-14T20:58:38.000Z","updated":"2019-09-16T03:23:28.694Z","comments":true,"path":"2019/09/15/14List集合/","link":"","permalink":"https://chensnape.github.io/2019/09/15/14List集合/","excerpt":"","text":"List集合、泛型机制、Queue集合、set集合2019/8/16 9:43:11 List集合(重中之重)基本概念java.util.List集合是Collection集合的子集合，该集合中元素有先后顺序且可以重复 该集合的作用实现类有：Array类、LinkedList类、Stack类、Vector类 其中ArrayList类的底层是采用动态数组进行数据管理的，访问方便但增删不方便 其中LinkedList类的底层是采用双向链表进行数据管理的，访问不方便但增删方便 其中Stack类的底层是采用动态数组进行数据管理的，该类主要用于描述具有后进先出的特性的数据结构，叫 做栈（last in first out LIFO）； 其中Vector类的底层采用动态数组进行数据管理的，与ArrayList类相比该类属于线程安全的类，因此效率比较低常用方法(练熟、记住)作业：(1)重点掌握集合框架的两张图和List集合的常用方法。 (2)查询java.util.Stack类，实现将11 22 33 44 55依次入栈再出栈。","categories":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/tags/java/"},{"name":"List集合","slug":"List集合","permalink":"https://chensnape.github.io/tags/List集合/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}]},{"title":"13日期类、集合","slug":"13日期类、集合","date":"2019-09-14T20:58:07.000Z","updated":"2019-09-16T03:23:17.882Z","comments":true,"path":"2019/09/15/13日期类、集合/","link":"","permalink":"https://chensnape.github.io/2019/09/15/13日期类、集合/","excerpt":"","text":"String类、StringBuilder类和StringBuffer类、日期相关的类、集合框架、Collection集合2019/8/15 10:51:33 String类 (重中之重)常用方法(练熟、记住)StringBuilder类和StringBuffer类(重点)基本概念（笔试题）由于String描述的字符串是个常量不可更改，若Java程序中出现大量类似的字符串时需要单独存储 造成内存空间的浪费，此时可以使用StringBuilder类或StringBuffer类取代String类型 来描述可以改变的字符序列。 java.lang.StringBuffer类从jdk1.0开始出现，属于线程安全的类，因此效率比较低 java.lang.StringBuilder类从jdk1.5开始出现，属于线程不安全的类，因此效率比较高常用方法(练熟)日期相关的类(会用即可)Date类(1)基本概念 java.util.Date类主要用于描述特定的瞬间(年月日时分秒)，可以精确到毫秒。 (2)常用方法SimpleDateFormat类(1)基本概念 java.text.SimpleDateFormat类可以实现日期和文本之间的转换 (2)常用方法Calendar类(1)基本概念 java.util.Date类主要用于取代Date类实现年月日时分秒的描述，可以实现全球化 该类是个抽象类，因此不能创建对象，只能使用多态的方式使用。集合框架集合的由来当需要在程序中记录单个数据内容时，则声明一个变量即可； 当需要在程序中记录多个类型相同的数据内容时，则声明一个一维数组即可； 当需要在程序中记录多个类型不同的数据内容时，则创建一个对象即可； 当需要在程序中记录多个类型相同的对象时，则声明一个对象数组即可； 当需要在程序中记录多个类型不相同的对象时，则声明一个集合即可；集合的框架Java语言中顶层集合有两种：java.util.Collection集合和java.util.Map集合 其中Collection集合中存取元素的基本单位是：单个元素 其中Map集合中存取元素的基本单位是：单对元素 在以后的开发中很少直接使用Collection集合，而是更多的使用该集合的子集合。Collection集合(重点)常用的方法(练熟、记住)作业(1)重点掌握集合框架的两张图和Collection集合的常用方法。 (2)使用StringBuilder类将字符串&quot;ABCD&quot;转换为&quot;A,B,C,D&quot;并打印出来 (3)提示用户按照指定的格式输入生日信息，计算距离1970年1月1日的天数并打印出来 如输入格式：1998年1月5日","categories":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/tags/java/"},{"name":"日期类、集合","slug":"日期类、集合","permalink":"https://chensnape.github.io/tags/日期类、集合/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}]},{"title":"12包装类、数学处理类、String类、常量池","slug":"12包装类、数学处理类、String类、常量池","date":"2019-09-14T20:57:30.000Z","updated":"2019-09-16T03:22:50.529Z","comments":true,"path":"2019/09/15/12包装类、数学处理类、String类、常量池/","link":"","permalink":"https://chensnape.github.io/2019/09/15/12包装类、数学处理类、String类、常量池/","excerpt":"","text":"包装类和数学处理类、String类2019/8/14 11:33:40 包装类和数学处理类(会用即可)回顾： Java语言是一门纯面向对象的编程语言，万物皆对象！ Java语言中的数据类型分为两大类：基本数据类型 和 引用数据类型123456int num = 10; public class MyInteger &#123; private int num = 10; - 成员变量&#125;MyInteger mi = new MyInteger(); 包装类的概念由于Java语言是一门纯面向对象的编程语言并且某些场合（集合）中要求所有的数据 都必须是对象，对于基本数据类型的变量来说无法满足该需求，因此Java官方提供了8 个类分别对8种基本数据类型进行包装处理，这些类就叫做包装类包装类的分类int =&gt; java.long.Integer类 char=&gt; java.long.Character类 剩下的其他类型都是将首字母换成大写Integer类(1)基本概念 java.long。Integer类是int类型的包装类，里面包含了一个int类型的成员变量 该类由final关键字修饰表示不能被继承 (2)常用方法BigDecimal类(1)基本概念 由于float类型和double类型在运算时可能会有误差，为了实现精确运算则可以借助 java.math.BigDecimal类型加以描述。 (2)常用方法String类(重中之重)基本概念java.lang.String类用于描述字符串，java程序中所有字符串字面值都可以使用该类 的实例(对象)加以描述，如：“abc”。 该类描述的字符串是个常量，一旦创建之后则无法修改，因此可以共享 该类由final关键字修饰表示该类不能被继承。 class SubString extends String(){} 如： String str1 = &quot;123&quot;; str1 = &quot;abc&quot;; - 将字符串“abc”的内存地址赋值给str1，也就是改变引用的指向常量池由于String类型描述的字符串内容是个常量不可改变，因此当Java程序中出现字符串时，Java虚拟机 会将该字符串放入常量池中，下次若出现同样的字符串则无需创建直接使用池中已有的字符串，从而提高效率。常用方法（练熟、记住）作业（1）重点掌握String类相关的代码。 （2）编程统计字符串&quot;ABCD123!@#$%ab&quot;中大写字母、小写字母、数字、其它字符的个数并打印出来 （3）首先输入学生人数，循环输入班级的学生信息，然后放入Student数组中，并打印所有姓zhang的学生信息。 要求姓名用拼音(不要用汉字),学生所有信息用String格式输入，中间用逗号隔开。 其中学生信息有：学号、姓名以及年龄。 提示： 需要查询String类中的split()方法进行字符串拆分，实参传递逗号(&quot;,&quot;)即可。 Student[] arr = new Student[10];","categories":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/tags/java/"},{"name":"包装类、数学处理类、String类、常量池","slug":"包装类、数学处理类、String类、常量池","permalink":"https://chensnape.github.io/tags/包装类、数学处理类、String类、常量池/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}]},{"title":"11接口、内部类、object类","slug":"11接口、内部类、object类","date":"2019-09-14T20:57:05.000Z","updated":"2019-09-16T03:22:18.820Z","comments":true,"path":"2019/09/15/11接口、内部类、object类/","link":"","permalink":"https://chensnape.github.io/2019/09/15/11接口、内部类、object类/","excerpt":"","text":"接口、匿名内部类、Object类2019/8/9 8:55:10 接口（重点）基本概念接口本质上就是一种比抽象类还抽象的类，体现在所有变量都是常量以及所有方法都是抽象方法. 定义抽象类的关键字是 abstract class ,而定义接口的关键字是interface. 如： 金属量 货币类 黄金类类接口之间的关系类和类之间的关系 使用extends关键字表达继承关系 支持单继承 类和接口之间的关系 使用implements关键字表达实现关系 支持多实现 接口和接口之间的关系 使用extends关键字表达继承关系 支持多继承抽象类和接口类的区别（笔试题）(1)定义抽象类的关键字是abstract class，而定义接口的关键字是interface； (2)继承抽象类的关键字是extends，而实现接口的关键字是implements； (3)继承抽象类支持单继承，而实现接口支持多实现； (4)抽象类中可以有构造方法，而接口中不可以有构造方法； (5)抽象类中可以有成员变量，而接口中只能有常量； (6)抽象类中可以有成员方法，而接口中只能有抽象方法； (7)抽象类中增加方法可以不影响子类，而接口中增加方法通常会影响子类； (8)从jdk1.8开始接口中允许有非抽象方法，但必须使用default关键字修饰；匿名内部类（重点、难点）语法格式接口/父类类型 引用变量名 = new 接口/父类类型() { 方法的重写 };经验的分享当接口类型的引用作为方法的形参时，实参的传递方式有两种： a.自定义属性接口，然后创建该类的对象作为实参传递； b.使用匿名内部类的语法格式得到接口类型的引用作为实参传递；实际作用当一个类存在的价值仅仅是为某一个类单独服务时，那么就可以将这个类定义为所服务类中的内部类 这样可以溢出该类的实现细节并且可以方便的访问外部类的私有成员而不再需要提供公有的get和set方法基本类型普通内部类 - 直接将一个类的定义放在另外一个类的类体中，隶属于对象层级 静态内部类 - 使用static关键字修饰的内部类，；隶属于类层级 局部内部类 - 直接将一个类的定义放在方法体的内部时 - 作用范围是从声明开始一直到方法体结束Object类常用的包java.lang包 - 该包是Java语言的核心包,该包中的内容由Java虚拟机自动导入 - 如：System类、String类等 java.util包 - 该包是Java语言的工具包，里面包含了大量的工具类以及集合类 - 如：Scanner类、Random类等 java.io包 - 该包是Java语言中的输入输出包，里面包含了大量读写文件类 - 如：FileInputStream类、FileOutputStream类等 java.net - 该包是Java语言的网络包，里面包含了大量网络编程的类 - 如：ServerSocket类、Socket类等Object类（1）基本概念 java.lang.Object；类是Java语言中类层次结构的 根类，任何类都是该类的直接或间接子类。 （2）常用的方法（重点） boolean equals(Object obj) - 用于判断当前正在调用的对象是否与参数对象相等 - 该方法默认比较两个对象的地址，与==的结果一致 - 为了比较两个对象的内容，需要重写该方法 - 当该方法被重写时，应该去重写hashCode方法 int hashCode() - 用于获取调用对象的哈希码值（内存地址编号） - 若两个对象调用equals方法的结果相等，则各自调用方法的结果就必须相同 - 若两个对象调用equals方法的结果不相等，则各自调用方法的结果就应该不相同 - 为了使得该方法的结果与equals方法保持一致，需要重写该方法 String tostring() - 用于获取调用对象的字符串形式 - 该方法返回的字符串默认格式为：包名.类名@哈希码的十六进制 - 为了使得该方法返回更有意义的数据，则重写该方法 - 使用print()或println()或字符串拼接引用变量时，都会自动调用toString方法练习(1)编程实现Runner接口，里面提供一个描述奔跑的抽象方法run； 编程实现Hunter接口继承自Runner接口，里面提供一个描述捕猎的抽象方法hunt； 编程实现Person类实现Hunter接口，在main方法中使用多态方式调用上述方法测试 (2) 编程实现Student类的封装，特征有：学号和姓名，要求提供打印所有特征的方法； 编程实现StudentTest类，在main方法中使用有参方式构造两个对象并打印特征作业(1)重点掌握Gold类相关的代码以及Student.java文件的代码。 (2)自定义Person类实现封装，特征有：姓名和年龄，要求以姓名为基准重写 equals方法、hashCode方法以及toString方法。 (3)自定义InterfaceA接口，里面含有一个抽象方法int method(int n)； 自定义ClassA类实现InterfaceA接口并重写method方法，要求计算1到n的和并返回 自定义ClassB类实现InterfaceA接口并重写method方法，要求计算n的阶乘并返回； 自定义InterfaceTest测试类，里面包含一个参数为InterfaceA接口形参的方法， 并在该方法体中调用method方法，最后在main方法中调用该方法。","categories":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/tags/java/"},{"name":"接口、内部类、object类","slug":"接口、内部类、object类","permalink":"https://chensnape.github.io/tags/接口、内部类、object类/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}]},{"title":"10访问控制、final、多态抽象类","slug":"10访问控制、final、多态抽象类","date":"2019-09-14T20:56:24.000Z","updated":"2019-09-16T03:22:06.867Z","comments":true,"path":"2019/09/15/10访问控制、final、多态抽象类/","link":"","permalink":"https://chensnape.github.io/2019/09/15/10访问控制、final、多态抽象类/","excerpt":"","text":"访问控制、final关键字、多态、抽象类2019/8/8 8:00:00 访问控制常用的访问控制符（笔试题）访问控制符 访问权限 本类内部 本包中的类 子类内部 其它包的类 public 公有的 ok ok ok ok protected 保护的 ok ok ok no 啥也不写 默认的 ok ok no no private 私有的 ok no no no 要求大家掌握的内容： a.public修饰的内容可以在任意位置使用； b.private修饰的内容只能在本类中使用； c.通常情况下，成员方法都使用public修饰，成员变量都使用private修饰；包的定义package 包名; - 为了方便管理以及避免命名冲突的问题 package 包名1.包名2...包名n; - 为了定义多层包final关键字（重点）基本概念final关键字本意为&quot;最终的，不可更改的&quot;，修饰类、成员方法以及成员变量等。使用方式final关键字修饰类体现在该类不能被继承。 - 为了防止滥用继承，如：java.lang.System类等 final关键字修饰成员方法体现在该方法不能被重写但可以被继承。 - 为了防止不经意间造成方法的重写，如：java.text.DateFormat类中format方法 final关键字修饰成员变量体现在该变量必须初始化而且不能更改。 - 为了防止不经意间造成的修改，如：java.lang.Thread类中MAX_PRIORITY等 扩展： 在以后的开发中很少单独使用static或final关键字修饰成员变量，而是使用public static final 这些关键字共同修饰成员变量表达常量的含义，常量的命名规范是：所有字母大写，不同的单词之间采用下划线连接，如： public static final double PI = 3.14;多态（重中之重）基本概念多态主要指同一种事物表现出来的多种形态。 饮料：可乐、雪碧、脉动、乐虎、红牛、... 宠物：猫、狗、鸟、乌龟、小强、... 人： 学生、教师、工人、保安、...语法格式父类类型 引用变量名 = new 子类类型(); Person p = new Worker(); p.show(); 解析： 编译阶段调用Person类型的show方法，运行阶段调用Worker类中的show方法多态的效果(1)当父类类型的引用指向子类类型的对象时，父类引用可以直接调用父类独有的方法； (2)当父类类型的引用指向子类类型的对象时，父类引用不可以直接调用子类独有的方法 (3)对于父子类都有的非静态方法来说，编译阶段调用父类版本，运行阶段调用子类版本 (4)对于父子类都有的静态方法来说，编译和运行阶段都调用父类版本； 引用类型之间的转换(1)Java语言中引用数据类型之间的转换分为：自动类型转换 和 强制类型转换。 其中自动类型转换主要指从小类型到大类型之间的转换，也就是子类到父类的转换 其中强制类型转换主要指从大类型到小类型之间的转换，也就是父类到子类的转换 (2)引用数据类型之间的转换必须发生在父子类之间，否则编译报错。 (3)若转换的目标类型并不是该引用真正指向的子类类型，则编译通过，运行阶段发生类型转换异常。 (4)为了避免上述问题的发生，应当在强转之前使用instanceof关键字进行检查，如下： if(引用变量名 instanceof 目标类型) - 判断引用指向的对象是否为目标类型实际意义多态的实际意义在于屏蔽不同子类的差异实现通用的编程而带来不同的效果。抽象类（重点）抽象方法的概念抽象方法就是指不能具体实现的方法，也就是没有方法体并使用abstract关键字修饰 语法格式如下： 访问权限 abstract 返回值类型 方法名称(形参列表);抽象类的概念抽象类就是指不能具体实例化的类，而且使用abstract关键字修饰。注意事项(1)抽象类中可以有成员变量、成员方法以及构造方法； (2)抽象类中可以没有抽象方法，也可以有抽象方法； (3)拥有抽象方法的类必须是抽象类，因此真正意义上的抽象类必须有抽象方法而且 使用abstract关键字修饰。实际意义抽象类的实际意义不在于自身创建对象而在于被继承，当一个类继承抽象类后必须重写抽象方法，否则该类也得变成抽象类。 抽象类对子类具有强制性和规范性，因此叫做 模板设计模式。练习编程实现Person类的封装，特征：姓名和年龄，要求提供打印所有特征的方法； 编程实现Worker类的封装并继承Person类，特征：薪水，要求提供打印特征的方法； 编程实现PersonWorkerTest类，在main方法中分别创建Person和Worker类型对象并打印特征。作业（1）重点掌握ShapeTest.java文件和抽象类相关的代码。 （2）自定义抽象类Account实现封装，特征：账户余额(balance)，在该类中提供一个 计算利息并返回的抽象方法。 自定义FixedAccount类继承Account类并重写抽象方法，要求在main方法中使用多态 方式构造对象并存入1000元，计算利息后打印出来(其中利率0.003)。","categories":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/tags/java/"},{"name":"访问控制、final、多态抽象类","slug":"访问控制、final、多态抽象类","permalink":"https://chensnape.github.io/tags/访问控制、final、多态抽象类/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}]},{"title":"9static、单例、继承","slug":"9static、单例、继承","date":"2019-09-14T20:55:57.000Z","updated":"2019-09-16T03:21:47.151Z","comments":true,"path":"2019/09/15/9static、单例、继承/","link":"","permalink":"https://chensnape.github.io/2019/09/15/9static、单例、继承/","excerpt":"","text":"static关键字、继承2019/8/7 10:56:05 static关键字基本概念+ 通常情况下成员变量隶属于对象层级，也就是每当创建一个对象就会申请一份独立的内存空间来存放该对象独立 的成员变量信息，若所有对象中某个成员变量的数值一定相同时还单独记录，则会造成内存空间的浪费。 + 为了解决上述问题，可以使用static关键字修饰成员变量来表达静态的含义，此时成员变量由对象层级提升为 类层级被所有对象共享，该成员变量会随着类的加载而准备就绪，与是否创建对象无关。 + static关键字还可以修饰成员方法，推荐使用 类名.的方式调用使用方式（1）在非静态成员方法中既能访问非静态的成员方法又能访问静态的成员； (成员：成员变量+成员方法 静态成员被所有对象共享) （2）在静态成员方法中只能访问静态成员不能访问非静态的成员； (成员：成员变量+成员方法 调用静态方法时可能还没有创建对象) （3）只有隶属于类层级被所有对象共享的内容才能使用static关键字修饰； (不能滥用static关键字)单例设计模式（重中之重）（1）基本概念 在某些特殊场合中，一个类对外提供且只提供一个对象，这样的类叫做单例类 而设计单例类的思想和模式叫做 单例设计模式。 （2）实现流程 a.私有化构造方法，使用private关键字修饰； b.声明本类类型的引用指向本类类型的对象，并使用private static关键字修饰； c.提供公有的get方法负责将对象返回出去，并使用static关键字修饰； （3）实现方式 单例设计模式的实现方式有两种：饿汉式 和 懒汉式，以后开发中推荐使用饿汉式继承（重中之重）基本概念+ 当多个类之间有相同的特征和行为时，可以将相同的内容提取出来组成一个公共类，让多个类吸收公共类中 已有成员然后在多个类内部编写自己独有成员的机制，叫做继承。 + 使用继承可以提高代码的复用性、可维护性以及扩展性。 + 在Java语言中使用extends（扩展）关键字来表达继承关系。 如： public class Worker extends Person{} - 表示Worker类继承自Person类 其中Person类叫做超类、父类、基类。 其中Worker类叫做派生类、子类、孩子类。注意事项(1)子类不可以继承父类的构造方法和私有方法，但私有成员变量可以继承不能使用； (2)无论使用何种方式构造子类对象时都会自动调用父类的无参构造方法来初始化从父类 中继承下来的成员变量相当于在构造方法的第一行增加代码：super()的效果。 (3)使用继承必须满足逻辑关系：子类 is a 父类，也就是不能滥用继承。 (4)Java语言中只支持单继承不支持多继承，也就是一个子类只能有一个父类，但一个父类可以有多个子类。方法的重写(Override)(1)基本概念 从父类中继承下来的版本不足以满足子类的需求时，就需要子类重新写一个和父类中一样的版本来覆盖从父类中继承的版本，该方式就叫做方法的重写。 (2)重写的原则 a.要求方法名相同、参数列表相同、返回值类型相同，从jdk1.5开始允许返回子类类型 b.要求访问权限不能变小，可以相同或者变大； c.要求不能抛出更大的异常(异常机制)；案例编程实现Singleton类的封装； 编程实现SingletonTest类进行Singleton类的测试，要求在main方法中能得到且只能得到Singleton类的一个对象。练习编程实现Person类的封装，特征有：姓名、年龄，行为：打印所有特征的方法 编程实现Worker类继承自Person类，Worker类内部暂时啥也不写 编程实现WorkerTest类，在main方法中使用无参方式构造对象并打印特征作业(1)重点掌握Singleton.java和Person.java以及Worker.java文件的代码。 (2)自定义矩形(Rect)类，特征有：横纵坐标、长度及宽度，要求实现封装并提供打印方法； 自定义圆形(Circle)类，特征有：横纵坐标、半径，要求实现封装并提供打印方法； 提取共性自定义图形(Shape)类。 自定义ShapeTest类，自定义成员方法实现既能打印矩形又能打印圆形的方法并调用 (最后一个成员方法选做)","categories":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/tags/java/"},{"name":"static、单例、继承","slug":"static、单例、继承","permalink":"https://chensnape.github.io/tags/static、单例、继承/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}]},{"title":"8this、传参过程、递归、封装","slug":"8this、传参过程、递归、封装","date":"2019-09-14T20:55:03.000Z","updated":"2019-09-16T03:21:21.430Z","comments":true,"path":"2019/09/15/8this、传参过程、递归、封装/","link":"","permalink":"https://chensnape.github.io/2019/09/15/8this、传参过程、递归、封装/","excerpt":"","text":"this关键字、方法的传参过程和递归调用、封装、static关键字2019/8/6 9:38:40 this关键字（原理、理解）基本概念若在构造方法中出现this关键字，则代表当前正在构造的对象； 若在成员方法中出现this关键字，则代表当前正在调用的对象；使用形式（1）当形参变量名和成员变量名同名时，在方法体中会优先使用形参变量，若希望使用 成员变量则需要在变量名的前面加上this.的前缀明确要求使用成员变量（掌握） （2）在构造方法的第一行可以使用this()的方式调用本类中的其它结构方法（了解）方法的传参过程和递归调用方法的传参过程（原理、理解）（1）main方法是程序的入口，先为main方法中变量申请内存空间并初始化； （2）调用max方法时，为max方法的形参变量申请内存空间； （3）将实参变量的数值赋值给形参变量，然后执行max的方法体； （4）当max方法体结束后，释放max方法形参变量所占的内存空间； （5）main方法得到max方法的返回值后继续向下执行； （6）当main方法结束后，释放main方法中局部变量的内存空间；要求大家掌握的内容a.当基本数据类型的变量作为参数传递时，形参变量数组的改变通常不影响实参变量 b.当引用数据类型的变量作为参数传递时，形参变量指向的内容发生改变后会影响到实参变量指向的内容 c.当引用数据类型的变量作为参数传递时，若形参变量改变指向后再改变指向的内容通常不会影响到实参变量指向的内容；方法的递归调用（重点、难点）（1）基本概念 递归主要指在方法体的内部调用当前方法身前的形式。 案例： 自定义成员方法实现参数n的阶乘计算并返回。 解析： 5！=5*4*3*2*1； 4！=4*3*2*1； 3！=3*2*1； 2！=2*1； 1！=1； n!=n*(n-1)*(n-2)*...*1; 解析： 5！=5*4!; 4!=4*3!; 3!=3*2!; 2!=2*1!; 1!=1; n!=n*(n-1)!; n=1时，return 1; （2）使用原则 a.必须找到递归的规律以及退出条件； b.使用递归必须使得问题简单化而不是复杂化； c.若递归影响到程序的执行性能，则使用递推取代之；封装（重中之重）基本概念通常情况下可以给成员变量赋值合法但不合理的数值， 无论编译阶段还是运行阶段都不会报错或给出提示，此时与现实生活不符。 为了避免上述错误的发生，需要对成员变量进行密封包装处理， 从而隐藏类中代码的细节以及保证成员变量值的合理性，该机制就叫做 封装。实现流程（1）私有化成员变量，使用private关键字修饰； （2）提供公有的get和set方法，在方法体中进行合理值的判断； （3）在构造方法中调用set方法进行合理值判断；作业1. 重点掌握Car.java文件的代码(20遍) 2. 分别使用递归和递推的方式计算费氏数列中第n项数值并返回(参考PPT) 3. 提示用户输入班级的学生人数以及每个学生的信息，学生的信息有：学号、姓名、 年龄，最后分别打印出来。 提示： Student[] arr = new Student[num]; 4. 编程实现Person类的封装，特征有：姓名、年龄、国籍 编程实现PersonTest类，在main方法中使用有参方式创建两个对象并打印特征","categories":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/tags/java/"},{"name":"this、传参过程、递归、封装","slug":"this、传参过程、递归、封装","permalink":"https://chensnape.github.io/tags/this、传参过程、递归、封装/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}]},{"title":"7成员方法、构造方法和方法重载","slug":"7成员方法、构造方法和方法重载","date":"2019-09-14T20:54:18.000Z","updated":"2019-09-16T03:20:46.917Z","comments":true,"path":"2019/09/15/7成员方法、构造方法和方法重载/","link":"","permalink":"https://chensnape.github.io/2019/09/15/7成员方法、构造方法和方法重载/","excerpt":"","text":"成员方法、构造方法和方法重载2019/8/5 8:56:47 成员方法（重中之重）语法格式class 类名{ 返回值类型 成员方法名（形参列表）{ 成员方法体； } }123456class Person&#123; void show()&#123; System.out.println(\"没事出来秀一下\"); &#125;&#125; 注意： 当成员方法名由多个单词组成时，通常要求从第二个单词起首字母大写。方法的详解（1）返回值类型 返回值主要指从方法体内向方法体外返回的数组内容。 返回值类型主要指返回值的数据类型，可以是基本数据类型，也可以是引用数据类型 如： 当返回的数据内容为66时，则返回值类型写int 即可 当返回的数据内容为3.14时，则返回值类型写double 即可 当返回的数据内容为&quot;hello&quot;时，则返回值类型写String 即可 在方法体中使用return 关键字实现数值的返回并结束当前方法。 如： 当返回的数据内容为66时，则方法体中写 return 66 即可; 当返回的数据内容为3.14时，则方法体中写 return 3.14 即可; 当返回的数据内容为num时，则方法体中写 return num 即可; 若该方法不需要返回任何数据内容时，则返回值类型写void即可。 （2）形参列表 形式参数主要用于将方法体外的数据带入方法体的内部 形参列表表示可以有多个形式参数，语法格式：数据类型 形参1，数据类型 形参2，... 如： 当传入的数据内容为66时，则形参列表写为 int i即可； 当传入的数据内容为3.14时，则形参列表写为 double d即可； 当传入的数据内容为&quot;hello&quot;时，则形参列表写为 String s即可； 当传入的数据内容为66 和&quot;hello&quot;时，则形参列表写为 int i, String S即可； 当传入的数据内容为3.14 和&quot;hello&quot;时，则形参列表写为 double d,String s即可； 当该方法不需要传入任何数据内容时，则形参列表位置啥也不写即可。 （3）成员方法体 成员方法中主要编写描述该方法功能的语句 如： 若该方法的功能时打印一句话时，则方法体中写：System.out.println(...); 若该方法的功能是找到最大值并返回时，则方法体中写：return ia&gt;ib？ia：ib;方法的调用（1）语法格式 引用变量名 .成员变量名（实参列表）; 如： p.show(); - 表示使用引用变量p调用名字为show 的成员方法 （2）注意事项 a.实际参数列表主要用于对形式参数列表进行赋值操作，因此参数的类型、参数的个数 以及参数的顺序必须保持一致； b.实际参数可以传递直接量、变量、表达式、方法的调用等；构造方法和方法重载123Person p =new Person(); - 表示声明Person类型的引用指向Person类型的对象p.show(); - 表示调用名字为show的方法 构造方法（重中之重）（1）语法格式 class 类名{ 类名（形参列表）{ 构造方法体； } }1234class Person&#123; Person()&#123; &#125;&#125; （2）注意事项 a.构造方法的名称与类名相同并且没有返回值类型，连void都不许有； b.当使用new关键字创建对象时会自动调用构造方法来实现成员变量的初始化 工作； （3）默认构造方法 a.当一个类没有自定义构造方法时，编译器会自动添加一个无参的空构造方法， 叫做默认/缺省构造方法，如：Person(){} b.若类中出现自定义构造方法，则编译不再提供任何形式的构造方法方法的重载（Overload 会用即可）（1）基本概念 在Java语言中方法名相同、参数列表不同的方法之间构成重载关系。 （2）方法重载的主要形式为：参数的个数不同、参数的类型不同、参数的顺序不同 与形参变量名以及返回值类型无关，但返回值类型最好相同。 判断能否重载的核心，调用能否区分。 （3）实际意义 方法重载的实际意义在于调用者只需要记住一个方法名就可以调用各种不同的版本， 从而实现各种不同的效果。char c1 ='a'; System.out.println(c1); int i1 =10; System.out.println(i1); double d1 =3.14 System.out.println(d1); ... ... 练习：（1）自定义Point类，特征有：横坐标和纵坐标，行为有：打印所有特征的数值 要求再main方法中声明Point类型的引用指向Point类型的对象并调用方法打印特征 再将特征修改为3和5后再次调用方法打印特征 自定义成员方法实现将横坐标修改为参数指定的数值 自定义成员方法实现将纵坐标修改为参数指定的数值 自定义成员方法实现获取横坐标的数值并返回的行为 自定义成员方法实现获取纵坐标的数值并返回的行为 （2）编程实现Girl类，特征有：姓名、年龄、是否有男朋友，行为有： 无参构造方法、有参构造方法、打印所有特征的方法。 要求在main方法中分别使用无参和有参方式构造对象并打印特征 （3）编程实现Worker类，特征有：姓名、年龄、薪水，行为有： 无参构造方法、有参构造方法、打印所有特征的方法、实现获取姓名并返回的方法、 修改姓名为参数指定数值的方法、获取年龄并返回的方法、修改年龄为参数指定数值的方法、 获取薪水并返回的方法、修改薪水为参数指定数值的方法、实现薪水增加500元的行为、 实现薪水增加参数指定数值的行为。要求在main方法中分别使用无参和有参方式构造对象并打印特征、 最后使用有参方式构造的对象调用上述方法测试。 作业（1）重点理解和掌握Worker.java文件的所有代码，至少敲20遍。 （2）自定义Car类，特征有：品牌(brand)、颜色(color)、价格(price)，行为有： 无参构造、三个参数的构造、打印所有特征的行为、获取品牌并返回的行为、获取颜色并返回的行为、 获取价格并返回的行为、设置品牌为参数指定的数值、设置颜色为参数指定的数值、 设置价格为参数指定的数值、实现价格增长1000元的行为、实现价格增长参数指定数值的行为。 要求在main()方法中使用无参形式构造对象打印特征，再使用有参形式构造对象打印特征 并使用有参形式构造的对象调用其他方法测试。","categories":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/tags/java/"},{"name":"成员方法、构造方法和方法重载","slug":"成员方法、构造方法和方法重载","permalink":"https://chensnape.github.io/tags/成员方法、构造方法和方法重载/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}]},{"title":"6二维数组、面向对象","slug":"6二维数组、面向对象","date":"2019-09-14T20:53:53.000Z","updated":"2019-09-16T03:20:31.165Z","comments":true,"path":"2019/09/15/6二维数组、面向对象/","link":"","permalink":"https://chensnape.github.io/2019/09/15/6二维数组、面向对象/","excerpt":"","text":"二维数组、面向对象编程的概念2019/8/2 14:02:20 二维数组（会用即可）基本概念 当需要在程序中记录多个数据内容时，则声明一个一维数组即可， 而一维数组本质上就是在内存中申请一段连续的存储单元。 二维数组本质上就是由多个一维数组摞在一起组成的数组，也就是说二维数组 中的每个元素都是一个一维数组，而一维数组中的每个元素才是数据内容。声明方式（1）语法格式 数据类型[][] 数组名称=new 数据类型[行数][列数]; 如： int[][] arr = new int[2][3]; - 表示声明具有2行3列元素类型为int的二维数组 其中行下标范围是：0 ~ 1； 其中列下标范围是：0 ~ 2； （2）元素初始化 数据类型[][] 数组名称 = {{初始值1,初始值2,...},...}; 如： int[][] arr = {{1, 2, 3}, {4, 5, 6}}; - 表示声明具有2行3列的二维数组面向对象编程的概念（理解）什么是对象？万物皆对象什么是面向对象？面向对象就是指以属性（特征）和行为的观点分析现实世界中事物的方式。什么是面向对象编程？面向对象编程就是指先以面向对象的方式进行分析，再使用面向对象的编程语言进行翻译的过程； 其中c语言是一门面向过程的编程语言； 其中c++语言是一门即面向过程又面向对象的编程语言； 其中Java语言是一门纯面向对象的编程语言。类和对象以及应用（重中之重、抽象、难点）类和对象的概念 对象主要指现实生活中客观存在的实体，在Java语言中体现为内存中的一块存储区域 类简单来说是“分类”的含义，是多个对象共性提取的抽象描述，在Java语言中体现为 一种引用数据类型，里面包含了描述特征的成员变量以及描述行为的成员方法。类的定义（1）类定义的语法格式 class 类名{ 类体； } 如： class Person{ } 注意： 当类名由多个单词组成时，通常要求每个单词的首字母都要大写。 （2）成员变量定义的语法格式 class 类名{ 数据类型 成员变量名 = 初始值； - 其中=初始值通常都省略 ... } 如： class Person{ String name; int age; } 注意： 当成员变量名由多个单词组成时，通常要求从第二个单词起首字母大写。 思考： 成员变量和局部变量有何区别？ 解析： 成员变量 - 定义在类体内方法体外的变量，作用范围从定义开始到整个类体结束 局部变量 - 定义在方法体内的变量，作用范围从定义开始到整个方法体结束对象的创建（1）语法格式 new 类名（）； 如： new Person(); - 表示创建Persin类型对象，由于该对象没有指定名称，叫匿名对象 （2）注意事项 a.使用new关键字创建对象的过程，叫做类的实例化； b.创建对象的本质就是在内存空间的堆区申请一块存储区域，用于记录该对象独有的特征信息。引用的定义（1）基本概念 使用引用数据类型定义的变量叫做 引用型变量，简称为引用； 引用变量通常用于记录对象在堆区中的内存地址信息，便于下次访问 （2）语法格式 类名 引用变量名 如： Person p; - 表示定义Person类型的引用 Person p = new Person(); - 表示声明Person类型的引用指向Person类型的对象 引用的变量名.成员变量名； 如： p.name=&quot;zhangfei&quot;;练习（1）编程实现Point类，特征有：横坐标(x)和纵坐标(y)，要求在main方法 声明Point引用指向Point对象并打印特征，修改特征为3和5后再次打印作业1. 要求重点理解一维数组的增删改查以及Person.java文件的代码， 其中Person类的代码至少敲20遍。 2. 自定义Phone类，特征有：品牌和价格，行为有：打印品牌和价格的方法， 要求在main()方法声明Phone类型的引用指向Phone类型的对象并打印特征， 将品牌和价格修改为&quot;Nokia&quot;和598后再次打印。","categories":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/tags/java/"},{"name":"二维数组、面向对象","slug":"二维数组、面向对象","permalink":"https://chensnape.github.io/tags/二维数组、面向对象/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}]},{"title":"5循环结构、一维数组","slug":"5循环结构、一维数组","date":"2019-09-14T20:53:26.000Z","updated":"2019-09-16T03:20:16.306Z","comments":true,"path":"2019/09/15/5循环结构、一维数组/","link":"","permalink":"https://chensnape.github.io/2019/09/15/5循环结构、一维数组/","excerpt":"","text":"循环结构、一维数组2019/8/1 14:03:13 循环结构双重循环（难点、重点）（1）语法格式 for(初始化表达式1；条件表达式2；修改初始值表达式3){ for(初始化表达式4；条件表达式5；修改初始值表达式6){ 循环体 } } （2）执行流程 执行表达式1=&gt;判断表达式2是否成立 =&gt;若成立，则执行表达式4=&gt;判断表达式5是否成立 =&gt;若成立，则执行循环体=&gt;执行表达式6=&gt;判断表达式5是否成立 =&gt;若不成立，则内层循环结束=&gt;表达式3=&gt;判断表达式2是否成立 =&gt;若不成立，则外层循环结束 （3）注意事项 a.外层循环变量变一下，内层循环从头到尾跑一圈 b.当需要打印多行多列时，则需要使用双重for循环；break关键字在嵌套的循环结构中，break用于退出所在循环体 如果要退出外层循环体，需要使用标号的方式 for(...){ outer:for(...){ for(...){ for(...){ break; break outer; } } } }while循环（会用）（1）语法格式 while（条件表达式）{ 循环体； } （2）执行流程 判断条件表达式是否成立 =&gt;若成立，则执行循环体=&gt;判断条件表达式是否成立 =&gt;若不成立，则结束循环 （3）注意事项 a.while循环和for循环都属于当型循环，完全可以互换； b.while循环更善于明确循环条件但不明确循环次数的场合； for循环通常更善于明确循环次数/循环范围的场合中； c.while(true)和for(;;)都表示无限循环；一维数组（重点）基本概念当需要在程序中记录单个数据内容时，则声明一个变量即可； 当需要在程序中记录多个类型相同的数据内容时，则声明一个一维数组即可 而一维数组本质上就是在内存中申请一段连续的存储单元；声明方式（1）语法格式 数据类型[] 数组名 =new 数据类型 [数组的长度] 如： int[] arr= new int[3]; - 表示声明一个长度为3元素类型为int类型的一维数组 int num =3; - 表示声明一个初始值为3元素类型为int类型的变量 int arr[] = new int[3] - 不推荐使用 （2）元素初始化 数据类型[] 数组名={初始值1, 初始值2, ...}; 如： int[] arr = {11, 22, 33, 44, 55}; - 声明数组的同时指定元素的初始值练习（1）提示用户输入一个正整数n，使用while循环实现1/1 + 1/2 + ...+1/n （2）使用双重for循环分别打印以下图案： ***** * i=1时，1个* ***** i=1时，5个* * ***** ** i=2时，2个* **** i=2时，4个* *** ***** *** i=3时，3个* *** i=3时，3个* ***** ***** **** i=4时，4个* ** i=4时，2个* ******* ***** *****i=5时，5个* * i=5时，1个* *********作业1. 重点掌握数组的声明和初始化方式 2. 编程实现九九乘法表的打印(参考PPT) 3. 声明一个长度为5元素类型为int类型的一维数组，打印数组中的所有元素值； 使用元素11、22、33、44分别对数组中的前四个元素赋值，再打印所有元素值； 将元素55插入到下标为0的位置，原有元素向后移动，再打印所有元素值； 再将元素55从数组中删除，删除方式为后续元素向前移动，最后位置置为0并打印； 查找数组中是否存在元素22，若存在则修改为220后再次打印所有元素； 4. 声明一个初始值为11 22 33 44 55的一维数组并打印所有元素 声明一个长度为3元素类型为int类型的一维数组并打印所有元素 实现将第一个数组中间3个元素赋值到第二个数组中 再次打印第二个数组中的所有元素 5. 编程统计用户输入任意一个正整数中每个数字出现次数的统计并打印。 如：123123 =&gt; 1出现2次，2出现2次，3出现2次 6. 编程实现双色球抽奖游戏(参考PPT)。","categories":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/tags/java/"},{"name":"循环结构、一维数组","slug":"循环结构、一维数组","permalink":"https://chensnape.github.io/tags/循环结构、一维数组/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}]},{"title":"4分支结构、循环结构","slug":"4分支结构、循环结构","date":"2019-09-14T20:50:08.000Z","updated":"2019-09-16T03:19:55.852Z","comments":true,"path":"2019/09/15/4分支结构、循环结构/","link":"","permalink":"https://chensnape.github.io/2019/09/15/4分支结构、循环结构/","excerpt":"","text":"分支结构、循环结构2019/7/31 9:07:27 分支结构（重中之重）基本概念当需要在Java程序中做出判断并作出选择时，就可以使用分支结构加以描述。if分支结构（1）语法格式 if（条件表达式）{ 语句块； } （2）执行流程 判断条件表达式是否成立 =&gt;若成立。则执行语句块； =&gt;若不成立，则跳过语句块不执行；if else 分支结构（1）语法格式 if（条件表达式）{ 语句块1； } else{ 语句块2； } （2）执行流程 判断条件表达式是否成立 =&gt;若成立，则执行语句块1； =&gt;若不成立，则执行语句块2；if-else if-else分支结构（1）语法格式 if（条件表达式1）{ 语句块1； } else if（条件表达式2）{ 语句块2； } ... ... else{ 语句块n; } （2）执行流程 判断条件表达式1是否成立 =&gt; 若成立，则执行语句块1； =&gt; 若不成立，则判断条件表达式2是否成立 =&gt; 若成立，则执行语句块2； =&gt; 若不成立，则执行语句块n；switch-case分支结构（了解）（1）语法格式 switch(变量/表达式){ case 直接量1: 语句块1; break; case 直接量2: 语句块2; break; ... ... default: 语句块n; } （2）执行流程 计算变量/表达式的数值 =&gt; 判断是否与直接量1匹配 =&gt; 若匹配，则执行语句块1 =&gt; 执行break跳出该结构； =&gt; 若不匹配，则判断是否与直接量2匹配 =&gt; 若匹配，则执行语句块2 =&gt; 执行break跳出该结构； =&gt; 若不匹配，则执行语句块n; （3）注意事项(笔试题) switch()中支持的类型有：byte、short、char以及int类型 从jdk1.5开始支持枚举类型，从jdk1.7开始支持String类型。循环结构（重中之重）基本概念当需要在Java程序中重复执行一段代码时，就需要使用循环结构加以处理。for循环（1）语法格式 for（初始化表达式；条件表达式；修改初始值表达式）{ 循环体； } （2）执行流程 执行初始化表达式 =&gt; 判断条件表达式是否成立 =&gt; 若成立，则执行循环体 =&gt; 执行修改初始值表达式 =&gt; 判断条件表达式是否成立 =&gt; 若不成立，则循环结束break和continuebreak关键字可以用在switch-case分支结构和循环结构中，用于跳出当前循环 continue关键字可以用在循环结构中表示结束本次循环继续下一次循环(熟悉)特殊的循环for(;;) - 这种没有循环条件的循环叫做无限循环，俗称“死循环”； - 使用break关键字搭配使用练习（1）使用for循环实现1 ~ 10000之间累加和的计算并打印 50005000 （2）提示用户输入一个整数，使用上述结构判断是正数、负数还是零 （3）提示用户输入一个整数，使用if-else分支结构判断负数还是非负数 （4）提示用户输入两个整数，使用if分支结构找到最大值并打印。 作业1.要求重点掌握if和for相关的所有案例代码。 2.求用户输入四个整数中的最大值并打印（参考PPT） 3.根据用户输入的个人薪水来计算个人所得税并打印，其中个税起征点为5000元(参考PPT) 个人所得税公式：应纳个人所得税税额=应纳税所得额×适用税率-速算扣除数 4.出租车计费系统的实现（参考PPT）。 5.使用for循环打印三位数中的所有水仙花数(参考PPT) 6.使用for循环实现将任意位数的正整数逆序输出。 7.编程实现猜数字游戏(参考PPT)，其中生成随机数的代码为： import java.util.Random; Random ra = new Random(); int num = ra.nextInt(100); - 表示生成0 ~ 99之间的整数存放到变量num中 8.提示用户输入一个整数，使用上述结构判断是正数、负数还是零(if-else if-else) 9.提示用户输入两个整数，使用if分支结构找到最大值并打印。","categories":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/tags/java/"},{"name":"分支结构、循环结构","slug":"分支结构、循环结构","permalink":"https://chensnape.github.io/tags/分支结构、循环结构/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}]},{"title":"3字符类型、运算符","slug":"3字符类型、运算符","date":"2019-09-14T20:49:37.000Z","updated":"2019-09-16T03:19:34.150Z","comments":true,"path":"2019/09/15/3字符类型、运算符/","link":"","permalink":"https://chensnape.github.io/2019/09/15/3字符类型、运算符/","excerpt":"","text":"字符类型、运算符2019/7/30 8:48:53 字符类型在Java语言中用于描述字符信息的类型有：char，如：&apos;1&apos;，&apos;a&apos;，&apos;中&apos;等... 其中char类型占用内存空间的大小为2个字节，在以后的开发中char类型很少使用 使用更多的是多个字符组成的字符串，使用&quot;&quot;括起来，并且用String类型加以描述 为了使得字符能够有效地记录到计算机中，给每个字符指定了一个编号，叫做 ASCII值 要求大家记住的ASCII值有： &apos;0&apos; - 48 &apos;A&apos; - 65 &apos;a&apos; - 97 空格 - 32 换行符 - 10 要求大家记住的转义字符有： \\&quot; - &quot; \\&apos; - &apos; \\\\ - \\ \\t - 制表符(tab键) \\n - 换行符基本数据类型之间的转换（尽量了解）在Java语言中数据类型之间的转换分为两大类： 自动类型转换 - 主要指从小范围到大范围之间的转换 强制类型转换 - 主要指从大范围到小范围之间的转换 - 目标类型 变量名 = (目标类型)源类型的变量名 - byte b1 = (byte)s1; - 在以后的开发中尽量少使用强制类型转换，因为可能会造成数据的丢失运算符（重点）算术运算符+ 表示加法运算发 - 表示减法运算符 * 表示乘法运算符 / 表示除法运算符 % 表示取余运算符关系运算符&gt;表示是否大于运算符 &gt;=表示是否大于等于运算符 &lt;表示是否小于运算符 &lt;=表示是否小于等于运算符 ==表示是否等于运算符 ！=表示是否不等于运算符 所有以关系运算符为最终运算的表达式结果都一定是boolean类型，只有true和false.自增减运算符+表示加法运算符 ++表示自增运算符，让变量自身的数值加1 -表示减法运算符 --表示自减运算符，让变量自身的数值减1逻辑运算符&amp;&amp; 表示逻辑与运算符，相当于“并且”，同真为真，一假为假 || 表示逻辑或运算符，相当于“或者”，一真为真，同假为假 ！ 表示逻辑非运算符，相当于“取反”，真为假，假为真 短路特性： 对于逻辑与运算符来说，若第一个条件为假则整个表达式为假，此时第二个条件跳过 对于逻辑或运算符来说，若第一个条件为真则整个表达式为真，此时第二个条件跳过条件/三目运算符条件表达式？表达式1：表达式2； =&gt;判断条件表达式是否成立 =&gt;若成立。则执行表达式1； =&gt;若不成立，则执行表达式2；赋值运算符（1）简单赋值 = 表示赋值运算符，用于将=右边的数值赋值给=左边的变量，覆盖变量原本的内容，切记不要与==混淆。 笔试题： ia == 2; - 表示判断ia的数值是否等于2 2 == ia; - 表示判断2是否等于ia的数值，推荐该方法 ia = 2; - 表示将数值2赋值给变量ia，覆盖ia原来的数值 2 = ia; - 编译报错 （2）复合赋值 +=、-=、*=、...运算符的优先级a. ()的优先级极高； b. = 的优先级极低； c. 若实在不确定执行次序，则使用()来确保优先级；作业1.要求重点掌握所有运算符的符号和功能以及时间拆分的案例。 2.提示用户输入一个三位数的正数，然后进行逆序处理再打印。 如： 123 =&gt; 321 打印 3.使用三目运算符判断用户输入的整数是负数、正数还是零。","categories":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/tags/java/"},{"name":"字符类型、运算符","slug":"字符类型、运算符","permalink":"https://chensnape.github.io/tags/字符类型、运算符/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}]},{"title":"2变量和注释、数据类型","slug":"2变量和注释、数据类型","date":"2019-09-14T20:48:59.000Z","updated":"2019-09-16T03:19:17.557Z","comments":true,"path":"2019/09/15/2变量和注释、数据类型/","link":"","permalink":"https://chensnape.github.io/2019/09/15/2变量和注释、数据类型/","excerpt":"","text":"变量和注释、数据类型2019/7/29 8:51:00 变量和注释（重中之重）变量的基本概念 当需要在Java程序中记录单个数据内容时，则声明一个变量即可，而变量的本质 就是在内存中申请一块存储单元，由于该存储单元中的数据内容可以改变，因此得名 为“变量”; 由于存放的数据内容大小不同导致所需存储单元的大小不同，在Java语言中使用数据 类型的概念加以描述，为了便于下次访问就需要给存储单元指定一个名称，叫做变量名。变量的声明方式数据类型 变量名 = 初始值； - 其中=初始值可以忽略，但分号不能省略 如： int age = 18; int age;标识符（变量名）的命名规则（1）要求由字母、数字、下划线以及美元$等组成，其中数字不能开头 如：age、name、nianling、age2、name2等 （2）要求不能与Java语言中关键字同名，所谓关键字就是Java语言中用于代表特殊含义的单词 如：public class void int等 （3）区分大小写，长度没有限制但不宜过长 如：Day和day代表两个不同的变量名，不推荐使用 （4）尽量做到见名知意，支持中文但不推荐使用 如：year、month、day、hour、minute、second、size、time等变量输入输出的优化123456789101112131415161718192021import java.util.Scanner;public class VarIOTest&#123; public static void main(String[] args)&#123; //1.声明两个变量用于记录姓名和年龄信息 //String name; //int age; //2.提示用户输入姓名和年龄信息并记录到上述变量中 System.out.println(\"请输入你的姓名年龄\"); //创建扫描器来扫描键盘输入的内容 Scanner sc = new Scanner(System.in); //读取一个字符串放到变量name中 String name = sc.next(); //读取一个整数放到变量age中 int age = sc.nextInt(); //3.打印用户输入的姓名和年龄 //System.out.println(\"name=\"+name); //System.out.println(\"age=\"+age); System.out.println(\"name =\"+name+\", age=\"+age); &#125;&#125; 注释// - 表示单行注释，从//开始一直到本行末尾的所有内容都是注释 /**/ - 表示多行注释，从/*开始一直到*/之间的所有内容都是注释 注意： 多好注释不允许嵌套使用！数据类型基本分类（记住）在Java语言中将数据类型分为两大类： （1）基本数据类型（记住） byte、short、int、long、float、double、boolean、char 1个 2个 4个 8个 4个 8个 1个 2个 （2）引用数据类型（了解） 数组、类、接口、标注、枚举常用的进制在现实生活中通常采用十进制，逢十进一，十进制的权重：10`0、10`1、... 在计算机的底层采用二进制，逢二进一，二进制权重：2`0、2`1、... 其中二进制的最高位（最左边）代表符号位，若该位时0则表示非负数，若该位是1则表示负数。 如： 10`3 10`2 10`1 10`0 千 百 十 个 1 2 3 4 =&gt;读作：一千两百三十四常用的进制转换（尽量理解、原理）（1）正的十进制转换成二进制的方式 a.除2取余法，让十进制整数不断的除以2并取出余数，直到商为0时将余数逆序排列 b.拆分法，将十进制整数拆分为若干个二进制权重的和，若由该权重下面写1否则写0 如： 45=&gt;32+8+4+1 128 64 32 16 8 4 2 1 0 0 1 0 1 1 0 1 =&gt;0010 1101 （2）正二进制转换为十进制的方式 a.加权法，让二进制中的每个数字乘以当前位的权重在累加起来 如： 0010 1101=&gt;0*2`7+0*2`6+1*2`5+0*2`4+1*2`3+1*2`2+0*2`1+1*2`0 =&gt;0+0+32+0+8+4+0+1 =&gt;45 （3）负十进制转换为二进制的方式 a.先将十进制整数的绝对值转换为二进制，在进行按位取反加1 如： -45 =&gt;绝对值转换为二进制： 0010 1101 =&gt;进行按位取反： 1101 0010 =&gt;再加1： 1101 0011 -45 + 45 =0； -45： 1101 0011 +45： 0010 1101 + ----------------- 1 0000 0000（高位溢出、丢弃，结果是：0） （4）负二进制转换为十进制的方式 a.先减1再进行按位取反，最后合并为十进制整数后增加负号 如： 1101 0011 =&gt;先减一： 1101 0010 =&gt;按位取反： 0010 1101 =&gt;合并十进制： 45 =&gt;添加负号： -45单个字节表示的整数范围（重中之重）在计算机中单个字节表示8位二进制，其中最高位（最左边）代表符号位 若该位是0代表非负数，若该位是1则代表负数，因此单个字节表示的整数范围如下： 非负数的范围： 0000 0000~0111 1111 =&gt;0~2`7-1=&gt;0~127 0111 1111 =&gt;0*128+1*64+1*32+1*16+1*8+1*4+1*2+1*1 =&gt;0+64+32+16+8+4+2+1 =&gt;127 负数的范围： 1000 0000~1111 1111 =&gt; 1000 0000 =&gt;先减1： 0111 1111 =&gt;按位取反： 1000 0000 =&gt;转十进制： 128 =&gt;添加负号： -128 1111 1111 =&gt;先减1： 1111 1110 =&gt;按位取反： 0000 0001 =&gt;转十进制： 1 =&gt;添加负号： -1 综上所述： 计算机中单个字节所能表示的整数范围是：-2`7~2`7-1,也就是-128~127.整数类型在Java语言中用于描述整数数据的数据类型由：byte、short、int、long,推荐int 其中byte类型在内存空间中占1个字节，表示的整数范围是：-2`7~2`7-1 -128~127 其中short类型在内存空间中占2个字节，表示的整数范围是：-2`15~2`15-1 -32768~32767 其中int类型在内存空间中占4个字节，表示的整数范围是：-2`31~2`31-1 正负二十一亿 其中long类型在内存空间中占8个字节，表示的整数范围是：-2`63~2`63-1 比int类型还大的数 在Java程序中直接写出的整数数据叫做 直接量/字面值/常量，如：66，默认为int类型 若希望表达更大的直接量，则需要在直接量的后面加上l或者L，推荐使用L。 扩展： 若希望表达比long类型还大的数据，则借助java.math.BigInteger类型加以描述。浮点类型在Java语言中用于描述小数数据的类型有：float、double，推荐使用double类型 其中float类型在内存空间中占4个字节，叫做单精度浮点数，小数点后通常有效到7位 其中double类型在内存空间中占8个字节，叫做双精度浮点数，小数点后通常有效15位 对于Java程序中直接写出的小数数据来说，叫做直接量/字面值/常量，如：3.14等 而直接量默认为double类型，若希望表达float类型的直接量就需要在直接量的后面加上f或者F都可以。 扩展： 由于Java语言中的float和double类型运算时可能会有误差 若希望实现精确运算则借助java.math.BigDecimal类型加以描述。布尔类型在Java语言中用于描述真假信息的数据类型有：boolean，数值只有：true 和 false 其中boolean类型在内存空间中所占的大小没有明确的规定，通常认为是1个字节 作业1.重点掌握变量输入输出的代码以及单个字节表示的整数范围。 2.思考题：设计一套砝码要求能称量出1 ~ 100g之间的任意重量，请问至少需要多少个砝码？ 以及每个砝码各自的重量是多少(砝码只能放在一侧)？ 3.编程题: 要求用户输入下落时间t(整数)，并按照公式0.5*9.8*t*t来计算下落的位移并打印出来。 其中小数数据使用double类型声明的变量来记录。 4.编程题(选做)：要求提示用户输入一个正整数类型的秒数，拆分为时分秒并打印出来。 + 加法 - 减法 * 乘法 / 除法 % 取余 如：3666 =&gt; 1:1:6","categories":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/tags/java/"},{"name":"变量和注释、数据类型","slug":"变量和注释、数据类型","permalink":"https://chensnape.github.io/tags/变量和注释、数据类型/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}]},{"title":"1常用快捷键","slug":"1常用快捷键","date":"2019-09-14T20:24:32.000Z","updated":"2019-09-14T15:26:04.624Z","comments":true,"path":"2019/09/15/1常用快捷键/","link":"","permalink":"https://chensnape.github.io/2019/09/15/1常用快捷键/","excerpt":"","text":"JavaSE2019/7/26 9:49:20 计算机的体系结构基本概念计算机俗称“电脑”，是一种呗广泛使用在各个领域的设备。 计算机主要由：硬件 和软件 两部分组成。常件硬件计算机中常件的硬件有：CPU、内存、硬盘、输入输出设备.... CPU - 中央处理器，是计算机最核心的部件，相当于人的大脑 - 主要用于解析并执行计算机指令以及处理软件中的数据 内存 - 是计算机中的存储部件 - 主要用于临时存放CPU要访问的数据内容，效率比较高 - 容量小且不能永久存储数据，一旦断电会造成数据丢失 - 使用ctrl+s快捷键可以进行数据保存 硬盘 - 是计算机中的存储部件； - 该部件中存储的内容不能被CPU直接访问，若希望访问则需要将数据加载到内存在访问； - 容量大且可以实现永久存储数据，断电后数据不会丢失。科普：1Tb = 1024Gb 1Gb = 1024Mb 1Mb = 1024Kb 1Kb = 1024byte(字节) 通常一个英文字母占一个字节，一个汉字占两个字节 1byte = 8bit(二进制) 在计算机的底层只识别0和1组成的二进制序列思考：目前主流的硬盘配置：250G 320G 500G 1Tb等，为啥我的硬盘只有298G呢？ 解析： 硬件厂商在生产硬件时按照1000作为进率，操作系统是按照1024作为进率。常件软件计算机中常见的软件分为：系统软件 和 应用软件。 其中系统软件主要指操作系统，目前主流的操作系统有： windows系列/Unix系列/linux系列/Android系列/ios系列 其中应用软件主要指安装在操作系统之上的软件，如：QQ、迅雷、...计算机的体系结构使用者 =》应用软件 =》操作系统 =》硬件 =》操作系统分为：外壳（Shell） 和 内核（Kernel）Java语言的基本概述（熟悉）Java语言的产生背景Java语言的诞生于1995年，高斯林是公认的Java语言之父，隶属于sun公司，现在隶属于oracle（甲骨文）公司。 Java语言在编程语言排行榜上占据重要的地位。Java语言的版本（1）JavaSE(Java Platform Standard Edition) - 称之为“Java平台标准版”，主要学校Java语言的语法格式和编程基础 （2）JavaEE(Java Platform Enterprise Edition) - 称之为“Java平台企业版”，主要学习Java项目的后台开发技术 （3）JavaME(Java Platform Micro Edition) - 称之为“Java平台微型版”，随着Android系统的普及走向淘汰开发环境的搭建和使用（重点）*****jdk的下载和安装（1）下载方式 a.从官网直接下载：www.oracle.com/www.sun.com b.从百度/谷歌/搜狗进行搜索下载 （2）安装方式 若下载的是绿色版，则直接解压即可 若下载的是安装版，则一路点击下一步进行安装即可 切记安装路径中不能有中文相关概念jdk - Java语言开发工具包，只要做Java语言开发就需要下载和安装该软件 jre - Java运行时环境，只要运行Java语言开发的程序就必须安装该软件 javac.exe - Java语言编辑器，负责将高级源代码文件编译成字节码文件 java.exe - Java语言的解释器，负责将字节码文件进行边解释边执行 JVM - Java虚拟机，用于作为Java语言和操作系统之间的桥梁。编写Java程序的流程（1）新建文本文档，将xxx.txt修改为xxx.java文件； （2）使用即使本的方式打开文件，编写Java语言代码后保存； （3）启动dos窗口。切换到 xxx.java所在目录； （4）使用javac xxx.java进行编译，生产xxx.class的字节码文件； （5）使用java xxx进行解释执行，打印最终结果。 注意： 当文件的后缀无法显示时：组织/工具 =》文件夹和搜索选项 =》查看 =》隐藏已知文件类型的扩展名 =》去掉勾选 =》确定常用快捷键***ctrl + s 保存 ctrl + n 新建 ctrl + c 复制 ctrl + v 粘贴 ctrl + x 剪切 ctrl + o 打开 ctrl + z 撤销 ctrl + a 全选 ctrl + f 查找 windows + e 打开计算机 windows + d 回到桌面 windows + l 锁屏 windows + r 打开运行，输入cmd回车可以打开dos窗口 windows + tab 切换任务 alt + tab 切换任务 ctrl + alt + delete 打开任务管理器 ctrl + shift 切换输入法，若切换到中文输入法后就可以使用shift进行中英文切换常用的dos命令d: 表示切换到d盘 cd 目录名/路径 表示切换到指定的目录中 dir 表示查看当前目录的内容 cls 表示清屏 cd .. 表示切换到上一级目录环境变量的配置***（1）基本概念 通常情况下的可执行文件只能在该文件所在的目录中使用，为了使得该可执行文件可以在任意的位置直接使用，此时就需要将Javac所在目录配置到环境变量Path中。 （2）配置方式 计算机 =&gt; 鼠标右击 =&gt; 属性 =&gt; 高级系统设置 =&gt; 高级 =&gt; 环境变量 =&gt; 系统变量 =&gt; 找到Path，点击编辑 =&gt; 将javac.exe所在的路径拷贝到Path变量值的最前面，添加分号 =&gt; 一路点击确定即可 切记Path变量值原来的内容不要改！ 配置环境变量后记得重启dos窗口！ win10系统不需要添加分号！跨平台原理（记住）由于不同的操作系统中都提供了Java虚拟机，因此可以将同一份字节码文件翻译成不同的 机器指令在不同的系统中执行，从而实现跨平台的效果，赢得了&quot;一次编译，到处使用&quot;的美名。","categories":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/tags/java/"},{"name":"快捷键","slug":"快捷键","permalink":"https://chensnape.github.io/tags/快捷键/"}],"keywords":[{"name":"java","slug":"java","permalink":"https://chensnape.github.io/categories/java/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-08-05T11:02:56.622Z","updated":"2019-09-14T10:47:17.137Z","comments":true,"path":"2019/08/05/hello-world/","link":"","permalink":"https://chensnape.github.io/2019/08/05/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post 1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}